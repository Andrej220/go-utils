=== ./backoff/backoff.go ===
package backoff

import (
	"math/rand"
	"time"
)

const (
	MaxElapsed     = 5 * time.Minute
	InitialBackoff = 1 * time.Second
	MaxBackoff     = 30 * time.Second
	DialTimeout    = 4 * time.Second
)

type Backoff struct {
	current time.Duration
	max     time.Duration
	rng     *rand.Rand
}

func New(initial, max time.Duration, seed int64) *Backoff {
	return &Backoff{
		current: initial,
		max:     max,
		rng:     rand.New(rand.NewSource(seed)),
	}
}

func (b *Backoff) Next() time.Duration {
	sleep := b.current/2 + time.Duration(b.rng.Int63n(int64(b.current/2)))
	b.current *= 2
	if b.current > b.max {
		b.current = b.max
	}
	return sleep
}

func (b *Backoff) Reset(initial time.Duration) {
	b.current = initial
}


=== ./backoff/go.mod ===
module github.com/azargarov/go-utils/backoff
go 1.22

=== ./backoff/backoff_test.go ===
package backoff

import (
	"testing"
	"time"
)

func TestNew(t *testing.T) {

	b := New(InitialBackoff, MaxBackoff, time.Now().UnixNano())
	if b == nil {
		t.Error("Expected non-nil Backoff instance")
		return
	}

	if b.current != InitialBackoff {
		t.Errorf("Expected current equal %d, got %d", InitialBackoff, b.current)
	}

	if b.max != MaxBackoff {
		t.Errorf("Expected max equal %d, got %d", MaxBackoff, b.max)
	}
}

func TestNext(t *testing.T) {
	b := New(InitialBackoff, MaxBackoff, time.Now().UnixNano())

	nxt := b.Next()

	if nxt < 0 || nxt > MaxBackoff {
		t.Error("Unxpected next value")
	}
}

func TestReset(t *testing.T) {
	b := New(InitialBackoff, MaxBackoff, time.Now().UnixNano())

	_ = b.Next()
	b.Reset(InitialBackoff)

	if b.current != InitialBackoff {
		t.Errorf("After Reset cxpected current equal to initial value %d, got %d", InitialBackoff, b.current)
	}
}


=== ./autostr/LICENSE ===
MIT License

Copyright (c) 2025 Andrey Zargarov

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

=== ./autostr/autostr.go ===
// Tag-based struct-to-string conversion.
//
// The autostr package provides a reflection-based utility to convert Go structs into human-readable strings using struct tags.
// It is designed for logging, debugging, and CLI output, offering flexible configuration for field inclusion, naming, formatting, and separators.
// If a type implements the AutoStringer interface, its AutoString method is used instead of reflection-based conversion.
//
// Example:
//
//	type Person struct {
//	    Name string `string:"include" display:"FullName" format:"%s"`
//	    Age  int    `string:"include" format:"%d years"`
//	}
//	p := Person{Name: "Alice", Age: 30}
//	fmt.Println(autostr.String(p)) // Output: FullName: Alice, Age: 30 years
package autostr

import (
	"fmt"
	"reflect"
	"strings"
)

// AutoStringer defines an interface for types that provide their own string representation.
// Types implementing AutoStringer will use their AutoString method instead of reflection-based conversion.
type AutoStringer interface {
	AutoString() string
}

// Constants defining default values for configuration.
const (
	// DefaultIncludeTag is the default struct tag key for including fields in the string output.
	DefaultIncludeTag = "string"
	// DefaultIncludeValue is the default tag value that indicates a field should be included.
	DefaultIncludeValue = "include"
	// DefaultFieldNameTag is the default struct tag key for renaming fields in the output.
	DefaultFieldNameTag = "display"
	// DefaultSeparator is the default separator between fields in the output.
	DefaultSeparator = ", "
	// DefaultFieldValueSeparator is the default separator between field names and their values.
	DefaultFieldValueSeparator = ": "
	// DefaultShowZeroValue determines whether zero values are included by default.
	DefaultShowZeroValue = true
	// DefaultFormat is the default format string for field values when no format tag is specified.
	DefaultFormat = "%v"
	// DefaultFormatTag is the default struct tag key for specifying field value formats.
	DefaultFormatTag = "format"
)

// Config defines options for customizing the string conversion process.
type Config struct {
	IncludeTag          string  // IncludeTag specifies the struct tag key for including fields (default: "string").
	IncludeValue        string  // IncludeValue specifies the tag value that includes a field (default: "include").
	FieldNameTag        string  // FieldNameTag specifies the struct tag key for renaming fields (default: "display").
	FieldValueSeparator *string // FieldValueSeparator is the separator between field names and values (default: ": ").
	Separator           *string // Separator is the separator between fields (default: ", ").
	ShowZeroValue       bool    // ShowZeroValue determines whether zero-value fields are included (default: true).
	FormatTag           string  // FormatTag specifies the struct tag key for formatting field values (default: "format").
	PrettyPrint         bool    // print multiline values in a pretty way
}

// Ptr creates a pointer to a value of any type.
// It is a helper function for setting pointer-based fields in Config, such as Separator or FieldValueSeparator.
//
// Example:
//
//	cfg := Config{Separator: Ptr(":")} // Sets Separator to ":"
func Ptr[T any](v T) *T { return &v }

// DefaultConfig returns a Config with default values for struct-to-string conversion.
// The defaults are:
//   - IncludeTag: "string"
//   - IncludeValue: "include"
//   - FieldNameTag: "display"
//   - Separator: ", "
//   - FieldValueSeparator: ": "
//   - ShowZeroValue: true
//   - FormatTag: "format"
//
// Example:
//
//	cfg := DefaultConfig()
//	fmt.Println(String(Person{Name: "Alice", Age: 30}, cfg)) // Output: Name: Alice, Age: 30
func DefaultConfig() Config {
	return Config{
		IncludeTag:          DefaultIncludeTag,
		IncludeValue:        DefaultIncludeValue,
		FieldNameTag:        DefaultFieldNameTag,
		Separator:           Ptr(DefaultSeparator),
		FieldValueSeparator: Ptr(DefaultFieldValueSeparator),
		ShowZeroValue:       DefaultShowZeroValue,
		FormatTag:           DefaultFormatTag,
	}
}

// ensureDefaults sets default values for unset Config fields.
// It is an internal helper function and not intended for public use.
func ensureDefaults(cfg *Config) {
	if cfg.IncludeTag == "" {
		cfg.IncludeTag = DefaultIncludeTag
	}
	if cfg.IncludeValue == "" {
		cfg.IncludeValue = DefaultIncludeValue
	}
	if cfg.FieldNameTag == "" {
		cfg.FieldNameTag = DefaultFieldNameTag
	}
	if cfg.Separator == nil {
		cfg.Separator = Ptr(DefaultSeparator)
	}
	if cfg.FormatTag == "" {
		cfg.FormatTag = DefaultFormatTag
	}
	if cfg.FieldValueSeparator == nil {
		cfg.FieldValueSeparator = Ptr(DefaultFieldValueSeparator)
	}
}

// String converts a value to a human-readable string using struct tags and an optional Config.
// If the value (or its pointer) implements AutoStringer, its AutoString method is used.
// If no Config is provided, DefaultConfig is used.
// The function handles nested structs, pointers, interfaces, and cyclic references safely.
//
// Example:
//
//	type Person struct {
//	    Name string `string:"include" display:"FullName" format:"%s"`
//	    Age  int    `string:"include" format:"%d years"`
//	}
//	p := Person{Name: "Alice", Age: 30}
//	fmt.Println(String(p)) // Output: FullName: Alice, Age: 30 years
func String(obj any, config ...Config) string {
	cfg := DefaultConfig()
	if len(config) > 0 {
		cfg = config[0]
	}

	ensureDefaults(&cfg)

	// Prefer user-defined AutoString on value.
	if s, ok := any(obj).(AutoStringer); ok {
		return s.AutoString()
	}
	if vt := reflect.TypeOf(obj); vt != nil && vt.Kind() != reflect.Pointer {
		pv := reflect.New(vt)
		pv.Elem().Set(reflect.ValueOf(obj))
		if s, ok := pv.Interface().(AutoStringer); ok {
			return s.AutoString()
		}
	}

	visited := make(map[uintptr]bool) // cycle detection on pointers
	return stringifyValue(reflect.ValueOf(obj), cfg, visited)
}

// stringifyValue converts a reflect.Value to a string based on the provided Config and visited pointers.
// It is an internal helper function and not intended for public use.
func stringifyValue(v reflect.Value, cfg Config, visited map[uintptr]bool) string {
	if !v.IsValid() {
		return "<nil>"
	}

	if v.Kind() == reflect.Interface {
		if v.IsNil() {
			return "<nil>"
		}
		return stringifyValue(v.Elem(), cfg, visited)
	}

	if v.Kind() == reflect.Pointer {
		if v.IsNil() {
			return "<nil>"
		}
		ptr := v.Pointer()
		if visited[ptr] {
			return "<cycle>"
		}
		visited[ptr] = true
		return stringifyValue(v.Elem(), cfg, visited)
	}

	if v.Kind() != reflect.Struct {
		return fmt.Sprintf("%v", v.Interface())
	}

	t := v.Type()
	var sb strings.Builder
	sb.Grow(64)

	sep := *cfg.Separator
	kv := *cfg.FieldValueSeparator

	var indent int
	if cfg.PrettyPrint {
		indent = measureKeyColumnWidth(v, cfg)
	}

	for i := 0; i < v.NumField(); i++ {
		field := v.Field(i)
		ft := t.Field(i)

		if !field.CanInterface() {
			continue
		}

		tag := ft.Tag.Get(cfg.IncludeTag)
		if tag != cfg.IncludeValue {
			continue
		}

		if !cfg.ShowZeroValue && isZeroValue(field) {
			continue
		}

		if sb.Len() > 0 {
			sb.WriteString(sep)
		}
		displayName := ft.Tag.Get(cfg.FieldNameTag)
		if displayName == "" {
			displayName = ft.Name
		}
		sb.WriteString(displayName)
		val := formatValueWithVisited(field, ft.Tag.Get(cfg.FormatTag), cfg, visited)
		if cfg.PrettyPrint {
			pad := indent - len(displayName)
			val = formatValueAligned(val, " ", kv, indent, pad)
		} else {
			sb.WriteString(kv)
		}
		sb.WriteString(val)
	}
	return sb.String()
}

// formatValueAligned formats a value string so that its first line follows a
// key/column and its subsequent lines align under the value column.
//   - The first line is rendered as: strings.Repeat(indentChar, pad) + separator + firstLine
//   - Each following line is rendered as: strings.Repeat(indentChar, indent) + separator + line
//
// The function normalizes Windows newlines ("\r\n" → "\n") and trims only
// trailing '\n' from val. If val is empty, it returns an empty string.
// Parameters:
//   - val: the raw value text (may be multi-line).
//   - indentChar: the single-character string used for indentation (e.g., " ").
//   - separator: the string placed between key and value (e.g., ": " or "\t\t").
//   - indent: the total indent (in indentChar units) used for subsequent lines
//     (typically the maximum key width).
//   - pad: extra left padding (in indentChar units) applied before separator on
//     the first line (typically indent - len(key); negative values are treated as 0).
//
// Note: This function only formats the value portion; callers should write the key
// text before calling this function.
func formatValueAligned(val, indentChar, separator string, indent, pad int) string {
	if val == "" {
		return ""
	}
	if pad < 0 {
		pad = 0
	}
	val = strings.ReplaceAll(val, "\r\n", "\n")
	val = strings.Trim(val, "\n")
	lines := strings.Split(val, "\n")
	first := strings.Repeat(indentChar, pad) + separator + lines[0]
	if len(lines) == 1 {
		return first
	}

	prefix := strings.Repeat(indentChar, indent) + separator
	out := make([]string, 0, len(lines))
	out = append(out, first)
	for _, ln := range lines[1:] {
		out = append(out, prefix+ln)
	}
	return strings.Join(out, "\n")
}

// measureKeyColumnWidth returns the maximum printable key width for v,
// considering autostr rules. It inspects only exported struct fields that
// (1) are tagged with cfg.IncludeTag=cfg.IncludeValue and
// (2) are not zero when cfg.ShowZeroValue is false.
// If a field has cfg.FieldNameTag, that value is used as the key; otherwise
// the struct field name is used. Non-struct, nil, or unsupported values return 0.
func measureKeyColumnWidth(v reflect.Value, cfg Config) int {

	for v.IsValid() && (v.Kind() == reflect.Ptr || v.Kind() == reflect.Interface) {
		if v.IsNil() {
			return 0
		}
		v = v.Elem()
	}
	if !v.IsValid() || v.Kind() != reflect.Struct {
		return 0
	}

	max := 0
	t := v.Type()
	for i := 0; i < t.NumField(); i++ {
		ft := t.Field(i)
		fv := v.Field(i)

		if !fv.CanInterface() {
			continue
		}
		if ft.Tag.Get(cfg.IncludeTag) != cfg.IncludeValue {
			continue
		}
		if !cfg.ShowZeroValue && isZeroValue(fv) {
			continue
		}

		name := ft.Tag.Get(cfg.FieldNameTag)
		if name == "" {
			name = ft.Name
		}
		if n := len(name); n > max {
			max = n
		}
	}
	return max
}

// formatValueWithVisited formats a reflect.Value using the specified format string, Config, and visited pointers.
// It is an internal helper function and not intended for public use.
func formatValueWithVisited(field reflect.Value, format string, cfg Config, visited map[uintptr]bool) string {
	switch field.Kind() {
	case reflect.Interface, reflect.Pointer:
		return stringifyValue(field, cfg, visited)
	case reflect.Struct:
		if hasAutoStringTags(field, cfg) {
			return stringifyValue(field, cfg, visited)
		}
	}
	if format == "" {
		format = DefaultFormat
	}
	return fmt.Sprintf(format, field.Interface())
}

// isZeroValue checks if a reflect.Value represents a zero value for its type.
// It is an internal helper function and not intended for public use.
func isZeroValue(field reflect.Value) bool {
	switch field.Kind() {
	case reflect.String:
		return field.String() == ""
	case reflect.Ptr, reflect.Slice, reflect.Map, reflect.Interface, reflect.Chan, reflect.Func:
		return field.IsNil()
	default:
		return field.IsZero()
	}
}

// hasAutoStringTags checks if a struct value has any fields with the include tag specified in Config.
// It is an internal helper function and not intended for public use.
func hasAutoStringTags(v reflect.Value, cfg Config) bool {
	t := v.Type()
	for i := 0; i < v.NumField(); i++ {
		ft := t.Field(i)
		if ft.Tag.Get(cfg.IncludeTag) == cfg.IncludeValue {
			return true
		}
	}
	return false
}


=== ./autostr/CHANGELOG.md ===
# Changelog

All notable changes to the `autostr` module will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/), and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [0.1.5] - 2025-10-12

### Added
- **PrettyPrint mode** (`Config.PrettyPrint`) for aligned, multi-line value formatting with proper indentation.
- **Helper functions:**
  - `measureKeyColumnWidth` — computes key column width for aligned output.
  - `formatValueAligned` — aligns multi-line values under their corresponding key columns.
- **Extended test suite:**
  - Added PrettyPrint, alignment, and newline normalization tests.
  - Verified zero-value field exclusion effects on column width.
  - Confirmed support for custom separators including `\n`.

## [0.1.4] - 2025-10-09
### Fixed
- Docs and CI badge finalized; code formatted with `gofmt -s`.
### Maintenance
- Retracted versions [0.1.0–0.1.3] due to earlier force-moved tag and docs cleanup. Use 0.1.4+.

## [0.1.1] - 2025-10-09

### Added
- Support for `format` tag to customize field value formatting (e.g., `format:"%03d"` for zero-padded integers).

### Changed
- Updated `DefaultShowZeroValue` to `true` to include zero-value fields by default.

## [0.1.0] - 2025-09-08

### Added
- Initial release of `autostr`, a tag-based struct-to-string conversion library.
- Support for converting structs to human-readable strings using `string:"include"` tags.
- Custom field naming via `display` tags (e.g., `display:"FullName"`).
- Configurable separators (`Separator`, `FieldValueSeparator`) and zero-value display (`ShowZeroValue`).
- Support for the `AutoStringer` interface to override default string conversion.
- Safe handling of cyclic references with `<cycle>` output.
- Nested struct and pointer traversal.
- Comprehensive test suite covering basic functionality, nested structs, cycles, and configuration.
- CI/CD pipeline with GitHub Actions for testing, vetting, and code coverage.

=== ./autostr/README.md ===
# autostr  — Tag-based struct-to-string converter for Go


[![Go Reference](https://pkg.go.dev/badge/github.com/azargarov/go-utils/autostr.svg)](https://pkg.go.dev/github.com/azargarov/go-utils/autostr)
[![CI](https://github.com/azargarov/go-utils/actions/workflows/ci.yml/badge.svg)](https://github.com/azargarov/go-utils/actions/workflows/ci.yml)
[![Go Report Card](https://goreportcard.com/badge/github.com/azargarov/go-utils/autostr)](https://goreportcard.com/report/github.com/azargarov/go-utils/autostr)
[![codecov](https://codecov.io/gh/azargarov/go-utils/branch/main/graph/badge.svg)](https://app.codecov.io/gh/azargarov/go-utils)


`autostr` is a small, reflection-based Go library that automatically converts structs into human-readable strings using struct tags — similar to how `encoding/json` converts structs into JSON.

It’s designed for logging, debugging, and CLI output when you want control over **which fields** are shown and **how** they’re displayed — without writing manual `String()` methods.

---

## Features

- Tag-driven field inclusion (`string:"include"`)
- Custom field labels via tag (`display:"Alias"`)
- Nested struct and pointer traversal
- Optional `AutoString()` override per type
- Safe cycle detection for linked data
- Configurable separators and zero-value display
- Default configuration with lazy fallback (like `http.Client`)

---

## Example
```go
package main

import (
    "fmt"
    "github.com/azargarov/go-utils/autostr"
)

type Person struct {
    Name string `string:"include" display:"FullName"`
    Age  int    `string:"include"`
    ID   int    // excluded
}

func main() {
    p := Person{Name: "Alice", Age: 30}
    fmt.Println(autostr.String(p))
    // Output: FullName: Alice, Age: 30
}
```
---
## Installation

```bash
go get github.com/azargarov/go-utils/autostr
```


=== ./autostr/ROADMAP.md ===
# Roadmap

## Core behavior
- [ ] **Interface-cycle detection**: detect cycles reachable only via `interface{}` (separate `visitedIface` keyed by underlying pointer identity when available; fall back to (type, address) pairs for pointer-backed values).
- [ ] **Max-depth & truncation**: `Config.MaxDepth` and `Config.Truncate` (runes), with ellipsis `…` to avoid runaway output.
- [ ] **Per-field options**: support tag modifiers akin to struct tags, e.g. `string:"include,omitempty"` (omit zero per-field even if `ShowZeroValue=true`) and `string:"-"` to force-skip.
- [ ] **Field order control**: optional `order:"<int>"` tag to override struct declaration order.
- [ ] **Nested/inline control**: `inline:"true"` to flatten embedded structs (print their fields at the parent level).
- [ ] **Collections**: rules for slices/maps (limit length via `MaxItems`, stable map ordering by key fmt).
- [ ] **Stringer hooks**: prefer `fmt.Stringer` / `encoding.TextMarshaler` / `json.Marshaler` before reflection when present (opt-in via config).
- [ ] **Time & duration helpers**: default friendly formats with per-field override (`timeFormat:"2006-01-02 15:04"`).

## Formatting & UX
- [ ] **Unicode-aware alignment**: measure key width in runes (and optionally visual cells) to align with non-ASCII keys; guard without external deps, optionally add a `runeWidth` strategy hook.
- [ ] **Tab-stop alignment**: `indentChar="\t"` support with configurable tab width.
- [ ] **ANSI styling (opt-in)**: simple color themes for keys/colons/values for CLI logs; no ANSI by default.
- [ ] **PrettyPrint policy**: knobs for line wrapping (`WrapAt`), continuation prefix string (not only `indentChar+sep`).

## Performance
- [ ] **Reflection cache**: cache field metadata per `reflect.Type` (included fields, display names, formatters, zero-check funcs) using `sync.Map`.
- [ ] **Formatter fast-paths**: avoid `fmt.Sprintf` when `format == "%v"` and kind is basic (int, float, bool, string).
- [ ] **Builder reuse**: optional `sync.Pool` for `strings.Builder`/buffers in hot paths.
- [ ] **Zero-check specialization**: precompute zero-check closures per field kind to reduce `reflect.Value` calls.
- [ ] **Bench targets**: add micro-benchmarks for small/medium structs; set budget (e.g., ≤ 2 allocs, ≤ 1µs for small struct on amd64).

## Reliability & Safety
- [ ] **Fuzzing**: `go test -fuzz` corpus for random nested types (pointers, maps, slices, interfaces) to harden cycle/nil paths.
- [ ] **Panic safety**: recover from unexpected reflection panics and print `<error: ...>` when `Config.Safe=true`.
- [ ] **Race scan**: CI job with `-race` and parallel fuzz to catch shared cache hazards.

## API & DX
- [ ] **Stable API surface**: mark `Config` and `String` as v1-stable; keep internals (`ensureDefaults`, etc.) unexported.
- [ ] **Writer API**: `Write(obj any, w io.Writer, cfg ...Config) (int, error)` to avoid intermediate strings.
- [ ] **Examples**: GoDoc examples for PrettyPrint, nested structs, custom formats, zero-value policies.
- [ ] **README gallery**: before/after snippets for PrettyPrint, custom separators (`"\n"`, `" | "`), and multiline alignment.
- [ ] **Compatibility note**: document how map order is stabilized and any guarantees (or lack thereof).

## Housekeeping
- [ ] **Issue labels**: perf, formatting, api, bug, docs.
- [ ] **CI matrix**: Go 1.22–1.23; linux/windows/darwin; `-race`, `-covermode=atomic`.
- [ ] **Release checklist**: bump, changelog, tag, `pkg.go.dev` badges, example screenshots for PrettyPrint.

### Notes on interface-cycle detection
- Track pointer cycles as you do now (`map[uintptr]bool`).
- For `interface{}` values:
  - If the dynamic value is a pointer, use its address as usual.
  - If it’s a non-pointer but references heap data (e.g., slice/map), you can key by the pointer to its underlying header (read via reflection) to detect cycles through containers.
  - Keep a separate `visitedContainers` keyed by (type, pointer) for slices/maps.
- Keep it conservative: if identity can’t be established safely, don’t mark as visited to avoid false positives; rely on depth limits as a safety net.



=== ./autostr/autostr_test.go ===
package autostr_test

import (
	"github.com/azargarov/go-utils/autostr"
	"strings"
	"testing"
)

type Person struct {
	Name string `string:"include" display:"FullName"`
	Age  int    `string:"include"`
}

type Car struct {
	Make  string  `string:"include"`
	Price float32 `string:"include" format:"%.2f"`
}

type Outer struct {
	Person Person `string:"include"`
	Note   string `string:"include"`
}

type WithPtr struct {
	Next *WithPtr `string:"include"`
	V    int      `string:"include"`
}

type WithAuto struct {
	X int `string:"include"`
}

func (w *WithAuto) AutoString() string { return "WithAuto<X>" }

func Test_Defaults_Basic(t *testing.T) {
	p := Person{Name: "Alice", Age: 30}
	got := autostr.String(p)
	want := "FullName: Alice, Age: 30"
	if got != want {
		t.Fatalf("got %q, want %q", got, want)
	}
}

func Test_Nested_WithTags(t *testing.T) {
	o := Outer{
		Person: Person{Name: "Bob", Age: 40},
		Note:   "n1",
	}
	got := autostr.String(o)
	want := "Person: FullName: Bob, Age: 40, Note: n1"
	if got != want {
		t.Fatalf("got %q, want %q", got, want)
	}
}

func Test_EmptySeparators_AreRespected(t *testing.T) {
	cfg := autostr.DefaultConfig()
	cfg.Separator = autostr.Ptr("")
	cfg.FieldValueSeparator = autostr.Ptr("")

	p := Person{Name: "A", Age: 1}
	got := autostr.String(p, cfg)
	want := "FullNameAAge1"
	if got != want {
		t.Fatalf("got %q, want %q", got, want)
	}
}

func Test_ShowZeroValue(t *testing.T) {
	p := Person{Name: "", Age: 0}
	cfg := autostr.DefaultConfig()
	cfg.ShowZeroValue = true
	got := autostr.String(p, cfg)
	want := "FullName: , Age: 0"
	if got != want {
		t.Fatalf("got %q, want %q", got, want)
	}
}

func Test_NilInterface_IsHandled(t *testing.T) {
	var x any = nil
	got := autostr.String(x)
	if got != "<nil>" {
		t.Fatalf("got %q, want <nil>", got)
	}
}

func Test_PointerReceiver_AutoString_Detected(t *testing.T) {
	got1 := autostr.String(WithAuto{X: 1})
	got2 := autostr.String(&WithAuto{X: 1})
	if got1 != "WithAuto<X>" || got2 != "WithAuto<X>" {
		t.Fatalf("AutoString not used: got1=%q got2=%q", got1, got2)
	}
}

func Test_Cycle_Detected(t *testing.T) {
	a := &WithPtr{V: 1}
	b := &WithPtr{V: 2}
	a.Next = b
	b.Next = a

	got := autostr.String(a)
	if got == "" || got == "<nil>" || got == "V: 1" {
		t.Fatalf("unexpected cycle handling: %q", got)
	}
	if !containsAll(got, []string{"V: 1", "V: 2", "<cycle>"}) {
		t.Fatalf("expected to contain V:1, V:2 and <cycle>, got %q", got)
	}
}

func Test_FieldDisplayNameTag(t *testing.T) {
	p := Person{Name: "Zoe", Age: 7}
	got := autostr.String(p)
	if got[:8] != "FullName" {
		t.Fatalf("display tag not applied: %q", got)
	}
}

func Test_FormatTag(t *testing.T) {
	p := Car{Make: "Opel", Price: 2.20}
	got := autostr.String(p, autostr.DefaultConfig())
	// "Make: Opel, Price: 2.20" -> the value starts at index 19
	if len(got) < 23 || got[19:] != "2.20" {
		t.Fatalf("format tag not applied correctly, got %q", got)
	}
}

func Test_ZeroValueConfig_FillsDefaults(t *testing.T) {
	cfg := autostr.Config{} // zero-value config; ensureDefaults should fill most defaults
	got := autostr.String(Person{"A", 2}, cfg)
	if got == "" || got == "<nil>" {
		t.Fatalf("defaults not applied: %q", got)
	}
}

// --- PrettyPrint & alignment tests ---

// Uses PrettyPrint=true to ensure multi-line values align under the value column.
// Also verifies that Windows newlines are normalized and trailing newlines trimmed.
func Test_PrettyPrint_MultilineAlignment(t *testing.T) {
	type Doc struct {
		Title string `string:"include" display:"T"`
		Body  string `string:"include" display:"Body"`
	}
	v := Doc{
		Title: "One",
		Body:  "line1\r\nline2\n", // includes Windows-style \r\n and trailing \n
	}

	cfg := autostr.DefaultConfig()
	cfg.PrettyPrint = true

	got := autostr.String(v, cfg)
	// indent = max(len("T"), len("Body")) = 4
	// For "T" (len=1): pad=3 => "T" + "   : One"
	// Separator between fields is ", "
	// For "Body" (len=4): pad=0, first line ": line1"; subsequent lines prefixed with 4 spaces + ": "
	// Windows newlines normalized and trailing newline trimmed
	want := "T   : One, Body: line1\n    : line2"
	if got != want {
		t.Fatalf("PrettyPrint alignment mismatch.\nGot:\n%q\nWant:\n%q", got, want)
	}
}

// Ensures that when ShowZeroValue=false, zero-value fields are omitted from both output
// and width calculation (so long key names that are zero don't affect alignment).
func Test_PrettyPrint_WidthIgnoresZeroWhenShowZeroFalse(t *testing.T) {
	type S struct {
		LongZero string `string:"include" display:"VeryLongKey"`
		Short    string `string:"include" display:"K"`
	}
	v := S{
		LongZero: "",    // zero-value, should be omitted
		Short:    "val", // only field shown
	}

	cfg := autostr.DefaultConfig()
	cfg.PrettyPrint = true
	cfg.ShowZeroValue = false

	got := autostr.String(v, cfg)
	// Because LongZero is omitted, indent = len("K") = 1; pad for "K" is 0
	// So no extra left spaces before ": "
	want := "K: val"
	if got != want {
		t.Fatalf("width calc with zero omitted mismatch.\nGot:  %q\nWant: %q", got, want)
	}
}

// Ensures PrettyPrint plays nicely with custom separators.
func Test_PrettyPrint_CustomSeparators_Newline(t *testing.T) {
	type P struct {
		A string `string:"include" display:"A"`
		B string `string:"include" display:"BBB"`
	}
	v := P{A: "x", B: "y\nz"}

	cfg := autostr.DefaultConfig()
	cfg.PrettyPrint = true
	cfg.Separator = autostr.Ptr("\n")
	cfg.FieldValueSeparator = autostr.Ptr(" : ")

	// indent = 3; colon column aligns across all lines:
	// "A"   -> pad=2 + " : "  => "A   : x"
	// "BBB" -> pad=0 + " : "  => "BBB : y"
	// cont  -> indent(3) + " : " => "    : z" (4 spaces before ':')
	want := "A   : x\nBBB : y\n    : z"
	got := autostr.String(v, cfg)
	if got != want {
		t.Fatalf("PrettyPrint with custom separators mismatch.\nGot:\n%q\nWant:\n%q", got, want)
	}
}

// Ensures PrettyPrint plays nicely with custom separators.
func Test_PrettyPrint_PipeSeparators(t *testing.T) {
	type P struct {
		A string `string:"include" display:"A"`
		B string `string:"include" display:"BBB"`
	}
	v := P{A: "x", B: "y\nz"}

	cfg := autostr.DefaultConfig()
	cfg.PrettyPrint = true
	cfg.Separator = autostr.Ptr(" | ")
	cfg.FieldValueSeparator = autostr.Ptr(" : ")

	want := "A   : x | BBB : y\n    : z"
	got := autostr.String(v, cfg)
	if got != want {
		t.Fatalf("PrettyPrint with custom separators mismatch.\nGot:\n%q\nWant:\n%q", got, want)
	}
}

// helpers
func containsAll(s string, parts []string) bool {
	for _, p := range parts {
		if !strings.Contains(s, p) {
			return false
		}
	}
	return true
}

type Bench struct {
	A string `string:"include"`
	B int    `string:"include"`
	C bool   `string:"include"`
	D int64  `string:"include"`
}

func BenchmarkString_Defaults(b *testing.B) {
	v := Bench{A: "hello", B: 42, C: true, D: 12345}
	for i := 0; i < b.N; i++ {
		_ = autostr.String(v)
	}
}


=== ./autostr/go.mod ===
module github.com/azargarov/go-utils/autostr

go 1.23
retract (
    [v0.1.0, v0.1.3] // retracted: earlier tags - missing docs and license; use v0.1.4+
)

=== ./zlog/stdlog_bridge.go ===
package zlog

import (
	"log"
	"strings"

	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

type zlogWriter struct {
	L     ZLogger
	Level zapcore.Level
}

func (w zlogWriter) Write(p []byte) (int, error) {
	msg := strings.TrimSpace(string(p))
	switch w.Level {
	case zapcore.DebugLevel:
		w.L.Debug(msg)
	case zapcore.WarnLevel:
		w.L.Warn(msg)
	case zapcore.InfoLevel:
		w.L.Info(msg)
	default:
		w.L.Error(msg)
	}
	return len(p), nil
}

func StdLoggerAt(lg ZLogger, lvl zapcore.Level) *log.Logger {
	if zl, ok := lg.(*zapLogger); ok && zl != nil {
		if std, err := zap.NewStdLogAt(zl.l, lvl); err == nil {
			return std
		}
		return zap.NewStdLog(zl.l)
	}
	return log.New(zlogWriter{L: lg, Level: lvl}, "", 0)
}


=== ./zlog/go.sum ===
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/stretchr/testify v1.8.1 h1:w7B6lhMri9wdJUVmEZPGGhZzrYTPvgJArz7wNPgYKsk=
github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
go.uber.org/goleak v1.3.0 h1:2K3zAYmnTNqV73imy9J1T3WC+gmCePx2hEGkimedGto=
go.uber.org/goleak v1.3.0/go.mod h1:CoHD4mav9JJNrW/WLlf7HGZPjdw8EucARQHekz1X6bE=
go.uber.org/multierr v1.10.0 h1:S0h4aNzvfcFsC3dRF1jLoaov7oRaKqRGC/pUEJ2yvPQ=
go.uber.org/multierr v1.10.0/go.mod h1:20+QtiLqy0Nd6FdQB9TLXag12DsQkrbs3htMFfDN80Y=
go.uber.org/zap v1.27.0 h1:aJMhYGrd5QSmlpLMr2MftRKl7t8J8PTZPA732ud/XR8=
go.uber.org/zap v1.27.0/go.mod h1:GB2qFLM7cTU87MWRP2mPIjqfIDnGu+VIO4V/SdhGo2E=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=


=== ./zlog/README.md ===
# zlog

Minimal wrapper around Uber’s [`zap`](https://pkg.go.dev/go.uber.org/zap) that provides:
- Interface: `ZLogger`
- Dev/Prod presets (env-driven)
- JSON or console output
- Context helpers (`Attach`, `FromContext`)
- Safe fallback logger using stdlib `log` with flat `k=v` fields
- `Discard` no-op logger for tests

---

## Install

```bash
go get github.com/Andrej220/go-utils/zlog
```

```go
import "github.com/Andrej220/go-utils/zlog"
```

## Quick start

```go
lg := zlog.NewDefault("my-service")
defer lg.Sync()

lg.Info("started",
    zlog.String("env", "dev"),
    zlog.Int("port", 8080),
)
```

### Custom config

```go
cfg := &zlog.Config{
    ServiceName: "my-service",
    Debug:       false,                       // or true
    Format:      zlog.ZLoggerJsonFormat,      // or zlog.ZLoggerConsoleFormat
}
lg := zlog.New(cfg)
defer lg.Sync()
```

### Context usage

```go
ctx := zlog.Attach(context.Background(), lg)
zlog.FromContext(ctx).Info("request",
    zlog.String("path", "/health"),
)
```

## Fields

Typed helpers (recommended):
```go
zlog.String("user", "alice")
zlog.Int("age", 30)
zlog.Bool("ok", true)
zlog.Float64("score", 0.97)
zlog.Time("at", time.Now())
zlog.Error("err", err)
zlog.Any("raw", map[string]any{"k":"v"}) // may be JSON-ish in console output
```

## Formats

- `json` (default) — machine-friendly.
- `console` — human-friendly (set `LOG_FORMAT=console`).

> The fallback stdlib logger prints fields as `key=value key2=value2` via an internal `flatten` helper.

## Environment variables

- `APP_DEBUG`: `true` / `1` ⇒ dev mode (higher verbosity).
- `LOG_FORMAT`: `json` | `console`.

`NewDefault()` reads both.

## Testing

No-op logger:
```go
lg := zlog.Discard
lg.Info("no output", zlog.String("k","v"))
```

Use your logger in tests:
```go
func TestSomething(t *testing.T) {
    lg := zlog.NewDefault("test")
    defer lg.Sync()
    // ...
}
```

## Interface

```go
type ZLogger interface {
    Info(msg string, fields ...Field)
    Error(msg string, fields ...Field)
    Debug(msg string, fields ...Field)
    Warn(msg string, fields ...Field)
    With(fields ...Field) ZLogger
    Sync() error
}
```

## Notes

- `With(...)` attaches base fields; the fallback logger preserves them too.




=== ./zlog/logger_fromctl_stderr_test.go ===
// logger_fromctx_stderr_test.go
package zlog

import (
	"context"
	"os"
	"strings"
	"testing"
)

//func hijackFile(f **os.File) (restore func(), r *os.File, err error) {
//	pr, pw, err := os.Pipe()
//	if err != nil { return nil, nil, err }
//	old := *f
//	*f = pw
//	return func() { _ = pw.Close(); *f = old; _ = pr.Close() }, pr, nil
//}
//
//func readAllWithDeadline(t *testing.T, r io.Reader) string {
//	t.Helper()
//	var buf bytes.Buffer
//	done := make(chan struct{})
//	go func() { _, _ = io.Copy(&buf, bufio.NewReader(r)); close(done) }()
//	select {
//	case <-done:
//	case <-time.After(200 * time.Millisecond):
//	}
//	return buf.String()
//}

func TestFromContext_DefaultLoggerWritesToStderr(t *testing.T) {
	// Capture stdout (to assert nothing goes there)
	restoreOut, rOut, err := hijackFile(&os.Stdout)
	if err != nil {
		t.Fatalf("stdout hijack failed: %v", err)
	}
	defer restoreOut()

	// Capture stderr
	restoreErr, rErr, err := hijackFile(&os.Stderr)
	if err != nil {
		t.Fatalf("stderr hijack failed: %v", err)
	}
	defer restoreErr()

	// No logger in context -> defaultLogger (uses stdlib log)
	ctx := context.Background()
	lg := FromContext(ctx)

	lg.Info("fallback path")

	// Close writers to flush/unblock readers
	_ = os.Stdout.Close()
	_ = os.Stderr.Close()

	stdout := readAllWithDeadline(t, rOut)
	stderr := readAllWithDeadline(t, rErr)

	if strings.Contains(stdout, "fallback path") {
		t.Fatalf("expected no output on stdout, got: %q", stdout)
	}
	if !strings.Contains(stderr, "INFO: fallback path") {
		t.Fatalf("expected default logger to write to stderr; got: %q", stderr)
	}
}


=== ./zlog/logger_test.go ===
package zlog

import (
	"bufio"
	"bytes"
	"context"
	"go.uber.org/zap/zapcore"
	"io"
	"log"
	"os"
	"strings"
	"testing"
	"time"
)

func TestStdLoggerAt_DefaultBackend_RoutesToError(t *testing.T) {
	var buf bytes.Buffer
	oldOut, oldFlags := log.Writer(), log.Flags()
	log.SetOutput(&buf)
	log.SetFlags(0)
	defer func() { log.SetOutput(oldOut); log.SetFlags(oldFlags) }()

	var d defaultLogger
	std := StdLoggerAt(d, zapcore.ErrorLevel)

	std.Println("boom")

	out := buf.String()
	if !strings.Contains(out, "ERROR: boom") {
		t.Fatalf("stdlog adapter did not route to defaultLogger.Error; got: %q", out)
	}
}

func TestStdLoggerAt_ZapBackend_NoPanic(t *testing.T) {
	lg := New(&Config{
		ServiceName: "test-service",
		Debug:       false,
		Format:      ZLoggerJsonFormat,
	})

	std := StdLoggerAt(lg, zapcore.ErrorLevel)
	if std == nil {
		t.Fatal("StdLoggerAt returned nil *log.Logger for zap backend")
	}

	std.Println("zap stdlog bridge smoke test")
}

func TestStdLoggerAt_DefaultBackend_RoutesToWarn(t *testing.T) {
	var buf bytes.Buffer
	oldOut, oldFlags := log.Writer(), log.Flags()
	log.SetOutput(&buf)
	log.SetFlags(0)
	defer func() { log.SetOutput(oldOut); log.SetFlags(oldFlags) }()

	var d defaultLogger
	std := StdLoggerAt(d, zapcore.WarnLevel)

	std.Println("heads up")

	out := buf.String()
	if !strings.Contains(out, "WARN: heads up") {
		t.Fatalf("expected WARN routing; got: %q", out)
	}
}

func TestNew_ProductionConfig(t *testing.T) {
	cfg := &Config{
		ServiceName: "test-service",
		Debug:       false,
		Format:      ZLoggerJsonFormat,
	}

	logger := New(cfg)
	if _, ok := logger.(*zapLogger); !ok {
		t.Error("Expected zapLogger in production mode")
	}
}

func TestNew_DebugConfig(t *testing.T) {
	cfg := &Config{
		ServiceName: "test-service",
		Debug:       true,
		Format:      ZLoggerConsoleFormat,
	}

	logger := New(cfg)
	if _, ok := logger.(*zapLogger); !ok {
		t.Error("Expected zapLogger in debug mode")
	}
}

// Test invalid config that should trigger fallback
func TestNew_FallbackToDefault(t *testing.T) {
	old := log.Writer()
	defer log.SetOutput(old)

	var buf bytes.Buffer
	log.SetOutput(&buf)

	cfg := &Config{
		ServiceName: "test-service",
		Debug:       false,
		Format:      "invalid format", // <-- must be an invalid encoding format
	}

	logger := New(cfg)
	if _, ok := logger.(defaultLogger); !ok {
		t.Error("Expecte default logger")
	}
}

func TestContextIntegration(t *testing.T) {
	logger := New(&Config{ServiceName: "test"})
	ctx := Attach(context.Background(), logger)

	retrieved := FromContext(ctx)
	if retrieved != logger {
		t.Error("Logger not properly retrieved from context")
	}
}

func TestFromContext_NoLogger(t *testing.T) {
	// Test empty context returns default logger
	logger := FromContext(context.Background())
	if _, ok := logger.(defaultLogger); !ok {
		t.Error("Expected defaultLogger from empty context")
	}
}

func TestWithFields(t *testing.T) {
	logger := New(&Config{ServiceName: "test"})
	loggerWithFields := logger.With(String("key", "value"))

	// Verify it returns the same type
	if _, ok := loggerWithFields.(*zapLogger); !ok {
		t.Error("With() should return same logger type")
	}
}

// Test that noopLogger methods don't panic
func TestDiscardLogger(t *testing.T) {
	Discard.Info("test")
	Discard.Error("test")
	Discard.With(String("key", "value"))
}

func TestDebugFromEnv(t *testing.T) {
	t.Setenv("APP_DEBUG", "true")
	if !DebugFromEnv() {
		t.Error("DebugFromEnv should detect true")
	}

	t.Setenv("APP_DEBUG", "false")
	if DebugFromEnv() {
		t.Error("DebugFromEnv should detect false")
	}
}

func TestFlattenFunction(t *testing.T) {
	result := flatten(String("user", "alice"), Int("age", 30))

	if !strings.Contains(result, "user=alice") || !strings.Contains(result, "age=30") {
		t.Errorf("Flatten failed: %s", result)
	}
}

// test force stderr functionality
func hijackFile(f **os.File) (restore func(), r *os.File, err error) {
	pr, pw, err := os.Pipe()
	if err != nil {
		return nil, nil, err
	}
	old := *f
	*f = pw
	restore = func() {
		_ = pw.Close()
		*f = old
		_ = pr.Close()
	}
	return restore, pr, nil
}

func readAllWithDeadline(t *testing.T, r io.Reader) string {
	t.Helper()
	var buf bytes.Buffer
	br := bufio.NewReader(r)

	done := make(chan struct{})
	go func() {
		io.Copy(&buf, br)
		close(done)
	}()

	select {
	case <-done:
	case <-time.After(200 * time.Millisecond):
	}
	return buf.String()
}

func TestNew_ForceStderr_RoutesAllToStderr(t *testing.T) {
	restoreStdout, rOut, err := hijackFile(&os.Stdout)
	if err != nil {
		t.Fatalf("stdout hijack failed: %v", err)
	}
	defer restoreStdout()

	restoreStderr, rErr, err := hijackFile(&os.Stderr)
	if err != nil {
		restoreStdout()
		t.Fatalf("stderr hijack failed: %v", err)
	}
	defer restoreStderr()

	lg := New(&Config{
		ServiceName: "test-svc",
		Debug:       false,
		Format:      ZLoggerJsonFormat,
		ForceStderr: true,
	})
	lg.Info("hello stderr", String("k", "v"))
	_ = lg.Sync()

	_ = os.Stdout.Close()
	_ = os.Stderr.Close()

	// ---- Assert: nothing on stdout; something on stderr ----
	stdout := readAllWithDeadline(t, rOut)
	stderr := readAllWithDeadline(t, rErr)

	if strings.Contains(stdout, "hello stderr") {
		t.Fatalf("expected no output on stdout, but found: %q", stdout)
	}
	if !strings.Contains(stderr, "hello stderr") {
		t.Fatalf("expected log on stderr, got: %q", stderr)
	}
}


=== ./zlog/go.mod ===
module github.com/azargarov/go-utils/zlog

go 1.23

require go.uber.org/zap v1.27.0

require go.uber.org/multierr v1.10.0 // indirect


=== ./zlog/logger.go ===
package zlog

import (
	"context"
	"fmt"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
	"log"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"time"
)

const (
	ZLoggerJsonFormat    = "json"
	ZLoggerConsoleFormat = "console"
	samplingInitial      = 100
	samplingAfter        = 100
)

// Field is a structured log field, aliasing zapcore.Field
type Field = zapcore.Field

func Any(key string, value any) Field         { return zap.Any(key, value) }
func String(key, value string) Field          { return zap.String(key, value) }
func Int(key string, value int) Field         { return zap.Int(key, value) }
func Int32(key string, value int32) Field     { return zap.Int32(key, value) }
func Bool(key string, value bool) Field       { return zap.Bool(key, value) }
func Float64(key string, value float64) Field { return zap.Float64(key, value) }
func Time(key string, value time.Time) Field  { return zap.Time(key, value) }
func Error(key string, value error) Field     { return zap.NamedError(key, value) }

// ZLogger defines the minimal interface for structured logging.
type ZLogger interface {
	Info(msg string, fields ...Field)
	Error(msg string, fields ...Field)
	With(fields ...Field) ZLogger
	Sync() error
	Debug(msg string, fields ...Field)
	Warn(msg string, fields ...Field)
}

// Config holds logging configuration options.
type Config struct {
	ServiceName string
	Debug       bool
	Format      string // "json" or "console"
	ForceStderr bool   // route all logs to stder
}

func DebugFromEnv() bool {
	return os.Getenv("APP_DEBUG") == "true" ||
		os.Getenv("APP_DEBUG") == "1" ||
		strings.EqualFold(os.Getenv("APP_DEBUG"), "true")
}

func FormatFromEnv(defaultFormat string) string {
	if format := os.Getenv("LOG_FORMAT"); format != "" {
		return format
	}
	if defaultFormat == "" {
		return ZLoggerJsonFormat
	}
	return defaultFormat
}

func New(cfg *Config) ZLogger {
	var baseCfg zap.Config

	if !cfg.Debug {
		cfg.Debug = DebugFromEnv()
	}

	if cfg.Debug {
		baseCfg = zap.NewDevelopmentConfig()
		baseCfg.EncoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
	} else {
		baseCfg = zap.NewProductionConfig()
		baseCfg.Level = zap.NewAtomicLevelAt(zap.InfoLevel)
	}

	// Allow console or JSON output
	baseCfg.Encoding = FormatFromEnv(cfg.Format)
	baseCfg.EncoderConfig.TimeKey = "timestamp"
	baseCfg.EncoderConfig.EncodeTime = zapcore.RFC3339TimeEncoder
	baseCfg.InitialFields = map[string]any{"service": cfg.ServiceName}

	// Enable sampling for high-throughput logs
	baseCfg.Sampling = &zap.SamplingConfig{Initial: samplingInitial, Thereafter: samplingAfter}

	if cfg.ForceStderr {
		baseCfg.OutputPaths = []string{"stderr"}
		baseCfg.ErrorOutputPaths = []string{"stderr"}
	}

	logger, err := baseCfg.Build(zap.AddCaller(), zap.AddStacktrace(zapcore.ErrorLevel))
	if err != nil {
		// Fall back to standard log if zap fails
		log.Printf("[FATAL] cannot initialize zap logger: %v", err)
		return defaultLogger{}
	}

	return &zapLogger{l: logger}
}

// NewDefault creates a logger with default configuration
func NewDefault(serviceName string) ZLogger {
	return New(&Config{
		ServiceName: serviceName,
		Debug:       DebugFromEnv(),
		Format:      FormatFromEnv(ZLoggerJsonFormat),
	})
}

// zapLogger wraps a *zap.ZLogger to implement ZLogger.
type zapLogger struct{ l *zap.Logger }

func (z *zapLogger) Info(msg string, fields ...Field) {
	z.l.Info(msg, fields...)
}

func (z *zapLogger) Error(msg string, fields ...Field) {
	z.l.Error(msg, fields...)
}

func (z *zapLogger) With(fields ...Field) ZLogger {
	return &zapLogger{z.l.With(fields...)}
}

func (z *zapLogger) Sync() error {
	return z.l.Sync()
}

func (z *zapLogger) Debug(msg string, fields ...Field) {
	z.l.Debug(msg, fields...)
}
func (z *zapLogger) Warn(msg string, fields ...Field) {
	z.l.Warn(msg, fields...)
}

// defaultLogger falls back to the standard log package.
type defaultLogger struct {
	base   []Field
	logger *log.Logger
}

func newDefaultLogger() *defaultLogger {
	return &defaultLogger{
		base: []Field{
			String("app", detectAppName()),
		},
		logger: log.New(os.Stderr, "", log.LstdFlags),
	}
}

// base holds persistent structured fields for this logger instance.
// We clone it before appending new fields to avoid slice aliasing.
func (d defaultLogger) Info(msg string, fields ...Field) {
	all := append(slices.Clone(d.base), fields...)
	d.logger.Println("INFO:", msg, flatten(all...))
}

func (d defaultLogger) Error(msg string, fields ...Field) {
	all := append(slices.Clone(d.base), fields...)
	d.logger.Println("ERROR:", msg, flatten(all...))
}

func (d defaultLogger) With(fields ...Field) ZLogger {
	all := append(slices.Clone(d.base), fields...)
	return defaultLogger{base: all}
}

func (d defaultLogger) Sync() error { return nil }
func (d defaultLogger) Debug(msg string, fields ...Field) {
	all := append(slices.Clone(d.base), fields...)
	d.logger.Println("DEBUG:", msg, flatten(all...))
}
func (d defaultLogger) Warn(msg string, fields ...Field) {
	all := append(slices.Clone(d.base), fields...)
	d.logger.Println("WARN:", msg, flatten(all...))
}

func flatten(fields ...zapcore.Field) string {
	// assert types
	enc := zapcore.NewMapObjectEncoder()
	for _, f := range fields {
		f.AddTo(enc)
	}

	if len(enc.Fields) == 0 {
		return ""
	}

	pairs := make([]string, 0, len(fields))
	for k, v := range enc.Fields {
		pairs = append(pairs, fmt.Sprintf("%s=%v", k, v))
	}
	return strings.Join(pairs, ", ")
}

// context key type for carrying ZLogger
type ctxKey struct{}

// Attach returns a new context with the provided ZLogger.
func Attach(ctx context.Context, lg ZLogger) context.Context {
	return context.WithValue(ctx, ctxKey{}, lg)
}

// FromContext retrieves the ZLogger from ctx, or falls back to defaultLogger.
func FromContext(ctx context.Context) ZLogger {
	if lg, ok := ctx.Value(ctxKey{}).(ZLogger); ok && lg != nil {
		return lg
	}
	return newDefaultLogger()
}

// noopLogger does absolutely nothing. For test only
type noopLogger struct{}

func (noopLogger) Info(msg string, _ ...Field)  {}
func (noopLogger) Debug(msg string, _ ...Field) {}
func (noopLogger) Error(msg string, _ ...Field) {}
func (noopLogger) Warn(msg string, _ ...Field)  {}
func (noopLogger) With(_ ...Field) ZLogger      { return noopLogger{} }
func (noopLogger) Sync() error                  { return nil }

var Discard ZLogger = noopLogger{}

func detectAppName() string {
	exe, err := os.Executable()
	if err == nil {
		return filepath.Base(exe)
	}
	return filepath.Base(os.Args[0])
}

//func _flatten(fields ...zapcore.Field) string {
//	enc := zapcore.NewConsoleEncoder(zapcore.EncoderConfig{ConsoleSeparator: " "})
//	buf, _ := enc.EncodeEntry(zapcore.Entry{}, fields)
//	defer buf.Free()
//	return strings.TrimSpace(buf.String())
//}


=== ./netfetch/release.yaml ===
name: Release netfetch

on:
  push:
    tags:
      - 'netfetch/v*'  # Trigger on version tags like v1.0.0

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'

      - name: Build netfetch binaries
        run: |
          # Build for multiple platforms
          GOOS=linux GOARCH=amd64 go build -o netfetch-linux-amd64 ./netfetch
          GOOS=linux GOARCH=arm64 go build -o netfetch-linux-arm64 ./netfetch
          GOOS=darwin GOARCH=amd64 go build -o netfetch-darwin-amd64 ./netfetch
          GOOS=darwin GOARCH=arm64 go build -o netfetch-darwin-arm64 ./netfetch
          GOOS=windows GOARCH=amd64 go build -o netfetch-windows-amd64.exe ./netfetch

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            netfetch-linux-amd64
            netfetch-linux-arm64
            netfetch-darwin-amd64
            netfetch-darwin-arm64
            netfetch-windows-amd64.exe
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

=== ./netfetch/go.mod ===
module github.com/Andrej220/go-utils/netfetch

go 1.23


=== ./netfetch/netf.go ===
package netfetch

import (
	"flag"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"
)

func showHelp() {
	fmt.Printf("Usage: %s [OPTIONS] URL\n", os.Args[0])
	fmt.Println("Options:")
	flag.PrintDefaults()
	fmt.Println("\nExamples:")
	fmt.Printf("  %s -v https://httpbin.org/get\n", os.Args[0])
	fmt.Printf("  %s -I https://httpbin.org/get\n", os.Args[0])
	fmt.Printf("  %s -s -X POST https://httpbin.org/post\n", os.Args[0])
}

func main() {
	// CLI flags
	verbose := flag.Bool("v", false, "Verbose mode (show headers)")
	silent := flag.Bool("s", false, "Silent mode (no progress/output)")
	head := flag.Bool("I", false, "Show headers only (HEAD request)")
	headLong := flag.Bool("head", false, "Show headers only (HEAD request)")
	timeout := flag.Int("timeout", 30, "Timeout in seconds")
	method := flag.String("X", "GET", "HTTP method (GET, POST, etc.)")
	help := flag.Bool("h", false, "Show help")

	flag.Parse()

	// Show help if requested or no URL provided
	if *help || len(flag.Args()) == 0 {
		showHelp()
		return
	}

	url := flag.Arg(0)

	// Validate URL format
	if !isValidURL(url) {
		fmt.Fprintf(os.Stderr, "Error: Invalid URL format: %s\n", url)
		os.Exit(1)
	}

	// Override method to HEAD if -I or --head is used
	if *head || *headLong {
		*method = "HEAD"
	}

	// Create HTTP client
	client := &http.Client{
		Timeout: time.Duration(*timeout) * time.Second,
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			if *verbose && len(via) > 0 {
				fmt.Fprintf(os.Stderr, "Redirect: %s -> %s\n", via[len(via)-1].URL, req.URL)
			}
			return nil
		},
	}

	// Create request
	req, err := http.NewRequest(*method, url, nil)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating request: %v\n", err)
		os.Exit(1)
	}

	// Make request
	if *verbose && !*silent {
		fmt.Fprintf(os.Stderr, "> %s %s HTTP/1.1\n", *method, url)
		fmt.Fprintf(os.Stderr, "> Host: %s\n", req.URL.Host)
		fmt.Fprintf(os.Stderr, "> User-Agent: go-curl/1.0\n")
		fmt.Fprintf(os.Stderr, "> \n")
	}

	resp, err := client.Do(req)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error making request: %v\n", err)
		os.Exit(1)
	}
	defer resp.Body.Close()

	// Output based on flags
	if (*head || *headLong) && !*silent {
		// HEAD mode: show only status and headers
		fmt.Printf("HTTP/%d.%d %d %s\n",
			resp.ProtoMajor, resp.ProtoMinor, resp.StatusCode, resp.Status)

		for key, values := range resp.Header {
			for _, value := range values {
				fmt.Printf("%s: %s\n", key, value)
			}
		}
		os.Exit(0)
	}

	if *verbose && !*silent {
		// Verbose output (like curl -v)
		fmt.Fprintf(os.Stderr, "< HTTP/%d.%d %d %s\n",
			resp.ProtoMajor, resp.ProtoMinor, resp.StatusCode, resp.Status)

		for key, values := range resp.Header {
			for _, value := range values {
				fmt.Fprintf(os.Stderr, "< %s: %s\n", key, value)
			}
		}
		fmt.Fprintf(os.Stderr, "< \n")
	}

	// Only read body if not HEAD request and not in silent mode
	if !(*head || *headLong) && !*silent {
		body, err := io.ReadAll(resp.Body)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error reading response: %v\n", err)
			os.Exit(1)
		}
		// Print response body to stdout
		fmt.Print(string(body))
	}

	// Exit code based on HTTP status
	if resp.StatusCode >= 400 {
		os.Exit(1)
	}
}

// Basic URL validation
func isValidURL(url string) bool {
	return len(url) > 7 && (url[:7] == "http://" || url[:8] == "https://")
}

// Show headers only (HEAD request)
// go run main.go -I https://httpbin.org/get
// go run main.go --head https://google.com
//
// Combine with verbose for more details
// go run main.go -I -v https://httpbin.org/get
//
// Regular request with headers and body
// go run main.go -v https://httpbin.org/get
//
// Silent HEAD request (useful for scripting)
// go run main.go -I -s https://httpbin.org/get && echo "Server is up!"


=== ./.githooks/pre-commit ===
#!/usr/bin/env sh
set -e
echo "Running gofmt -s..."
gofmt -s -w .
git add -A


=== ./.github/workflows/ci.yml ===
# https://docs.github.com/en/actions/tutorials/build-and-test-code/go
name: Go Tests

on:
  push:
    branches: [ main ]
    tags: [ '*/v*.*.*' ]   # e.g. autostr/v0.1.0
  pull_request:
    branches: [ main ]

permissions:
  contents: read

jobs:
  test_all:
    if: ${{ !startsWith(github.ref, 'refs/tags/') }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        go: [ '1.23.x' ]
        pkg: [ grlimit, zlog, backoff, wpool, httpsrv, autostr ]
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go }}
          cache: true
          cache-dependency-path: |
            **/go.sum

      - name: Go env (debug)
        run: go env

      - name: Vet (${{ matrix.pkg }})
        working-directory: ${{ matrix.pkg }}
        run: go vet ./...

      - name: Test (race + coverage) (${{ matrix.pkg }})
        working-directory: ${{ matrix.pkg }}
        run: |
          mkdir -p ../.coverage
          if compgen -G '*_test.go' > /dev/null; then
            go test -v -race -covermode=atomic -coverprofile=../.coverage/${{ matrix.pkg }}.out ./...
          else
            echo "No tests in $PWD — creating empty coverage profile"
            echo "mode: atomic" > ../.coverage/${{ matrix.pkg }}.out
          fi

      - name: Show generated coverage files
        run: ls -lah .coverage || true

      - name: Upload coverage artifacts
        if: ${{ hashFiles('.coverage/*.out') != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.go }}-${{ matrix.pkg }}
          path: .coverage/*.out

      - name: Upload coverage to Codecov
        if: ${{ hashFiles('.coverage/*.out') != '' && (github.event_name != 'pull_request' || github.event.pull_request.head.repo.fork == false) }}
        uses: codecov/codecov-action@v4
        with:
          files: .coverage/*.out
          flags: unittests,${{ matrix.pkg }}
          token: ${{ secrets.CODECOV_TOKEN }}
          fail_ci_if_error: false

  test_tag:
    if: ${{ startsWith(github.ref, 'refs/tags/') }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        go: [ '1.23.x' ]
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go }}
          cache: true
          cache-dependency-path: |
            **/go.sum

      - name: Detect package from tag
        id: tagpkg
        run: |
          # GITHUB_REF_NAME is like "autostr/v0.1.0"
          PKG="${GITHUB_REF_NAME%%/*}"
          if [ ! -d "$PKG" ]; then
            echo "Tag prefix '$PKG' does not match a directory. Exiting."; exit 1
          fi
          echo "pkg=$PKG" >> "$GITHUB_OUTPUT"

      - name: Gofmt (check, simplified)
        working-directory: ${{ steps.tagpkg.outputs.pkg }}
        run: |
          set -euo pipefail
          OUT="$(gofmt -s -l . || true)"
          if [ -n "$OUT" ]; then
            echo "The following files are not gofmt -s formatted:"
            echo "$OUT"
            echo
            echo "Diff (gofmt -s -d):"
            gofmt -s -d .
            exit 1
          fi
          
      - name: Vet (${{ steps.tagpkg.outputs.pkg }})
        working-directory: ${{ steps.tagpkg.outputs.pkg }}
        run: go vet ./...

      - name: Test (race + coverage) (${{ steps.tagpkg.outputs.pkg }})
        working-directory: ${{ steps.tagpkg.outputs.pkg }}
        run: |
          mkdir -p ../.coverage
          if compgen -G '*_test.go' > /dev/null; then
            go test -v -race -covermode=atomic -coverprofile=../.coverage/${{ steps.tagpkg.outputs.pkg }}.out ./...
          else
            echo "No tests in $PWD — creating empty coverage profile"
            echo "mode: atomic" > ../.coverage/${{ steps.tagpkg.outputs.pkg }}.out
          fi

      - name: Show generated coverage files
        run: ls -lah .coverage || true

      - name: Upload coverage artifacts
        if: ${{ hashFiles('.coverage/*.out') != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: coverage-tag-${{ matrix.go }}
          path: .coverage/*.out

      - name: Upload coverage to Codecov
        if: ${{ hashFiles('.coverage/*.out') != '' }}
        uses: codecov/codecov-action@v4
        with:
          files: .coverage/*.out
          token: ${{ secrets.CODECOV_TOKEN }}
          flags: unittests,tag
          fail_ci_if_error: false


=== ./codecov.yaml ===
codecov:
  require_ci_to_pass: false

coverage:
  precision: 2         
  round: down          
  range: "50...95"     

  status:
    project:
      default:
        target: auto   
        threshold: 1%  
        base: auto
    patch:
      default:
        target: auto   
        threshold: 1%  

comment:
  layout: "reach, diff, files"
  require_changes: false   
  behavior: default

ignore:
  - "**/*_generated.go"
  - "**/mock_*/*.go"
  - "**/mocks/**/*.go"
  - "**/internal/tools/**"
  - "**/vendor/**"
  - "**/examples/**"
  - "**/*.pb.go"           
  - "**/*.gen.go"          

flags:
  autostr:
    paths:
      - autostr/
  wpool:
    paths:
      - wpool/
  zlog:
    paths:
      - zlog/
  backoff:
    paths:
      - backoff/
  httpsrv:
    paths:
      - httpsrv/
  grlimit:
    paths:
      - grlimit/


=== ./grlimit/README.md ===
# grlimit — goroutine concurrency limiter (one‑shot)

`grlimit` is a tiny, dependency‑free **bounded‑concurrency executor**.  
It limits how many jobs run **at the same time**. `Submit` blocks when all slots are in use and resumes when a slot frees up or the caller’s context is canceled.

> This is **not** a classic worker “pool.” There’s no background worker fleet and no internal job queue. Each admitted job runs in its **own goroutine**; the “queue” is callers blocked in `Submit`.

---

## Install


```bash
go get github.com/Andrej220/go-utils/grlimit
```

---

## Quick start

```go
package main

import (
	"context"
	"fmt"
	"log"

	grlimit "github.com/Andrej220/go-utils/grlimit" 
)

// Optional adapter for quick inline jobs in examples/tests.
type JobFunc func(ctx context.Context) error
func (f JobFunc) Run(ctx context.Context) error { return f(ctx) }

func main() {
	g := grlimit.NewGate(8) // at most 8 jobs run concurrently

	// Consume errors until the gate shuts down.
	doneErrs := make(chan struct{})
	go func() {
		defer close(doneErrs)
		for err := range g.Errors() {
			log.Printf("job error: %v", err)
		}
	}()

	ctx := context.Background()

	// Submit some work. Submit blocks when all 8 slots are busy.
	for i := 0; i < 100; i++ {
		// Example job
		job := JobFunc(func(ctx context.Context) error {
			// do work; respect ctx
			return nil
		})
		if err := g.Submit(ctx, job); err != nil {
			// ctx canceled or gate shut down
			fmt.Println("submit:", err)
			break
		}
	}

	// Stop admissions and wait for all in‑flight jobs to finish.
	g.CloseAndWait()
	<-doneErrs
}
```

---

## API

```go
// Job represents a unit of work. Implementations should respect ctx for cancellation.
type Job interface {
    Run(ctx context.Context) error
}

// Gate limits the number of concurrently running jobs.
// One‑shot: after CloseAndWait, Submit returns ErrShutdown and Errors() is closed.
type Gate struct{ /* ... */ }

func NewGate(capacity int) *Gate
func (*Gate) Submit(ctx context.Context, j Job) error // blocks when full
func (*Gate) CloseAndWait()                           // shuts down & joins
func (*Gate) Errors() <-chan error                    // closes after join
func (*Gate) InUse() int                              // running jobs
func (*Gate) Available() int                          // free slots
func (*Gate) Capacity() int                           // max concurrency
```

**Errors:**  
- `ErrShutdown` — the gate has been closed and no longer accepts jobs.  
- `ErrNilJobSubmitted` — a nil job was submitted.

---

## Design

- Uses a **buffered channel as a semaphore**. Each admission sends a token (takes a slot); each job completion receives a token (releases the slot).
- `CloseAndWait()` flips the closed flag (future `Submit` → `ErrShutdown`) and then **fills the semaphore to capacity**, which blocks until all in‑flight jobs release their tokens. This is the join, implemented without a `sync.WaitGroup`.
- When the join completes, `Errors()` is **closed** so consumers can `range` and exit cleanly.

### Single‑use (one‑shot)

After `CloseAndWait()` returns, the gate **stays closed**. Create a new gate for another run.

### Cancellation & errors

- `Job.Run(ctx)` receives a context and should **return promptly** when `ctx` is canceled.
- Any non‑nil error returned from `Run` is sent to `Errors()`. The channel has a small buffer; if it fills, additional errors may be dropped (best‑effort). Size the buffer to your needs or log dropped sends.

### Concurrency semantics

- `Submit` blocks when at capacity; use the caller’s context for timeouts/deadlines.
- `InUse()` → number of currently running jobs.  
- `Capacity()` → maximum concurrency.  
- `Available()` → `Capacity() - InUse()`.

### Panic safety

Panics inside a job are **recovered** to avoid leaking a semaphore token. You should still log the panic (and stack) in your implementation.

---

## When to use

Use `grlimit` when you want **bounded concurrency** with simple admission control and a clean shutdown/join, but you **don’t need** a queued worker pool. If you need a fixed set of workers pulling from a buffered job queue, implement that separately (e.g., N workers reading from `jobs <-chan Job`).

---

## Testing & examples

Run the package tests:

```bash
go test -race -v ./...
```

A handy test adapter for jobs:

```go
type JobFunc func(ctx context.Context) error
func (f JobFunc) Run(ctx context.Context) error { return f(ctx) }
```

---



=== ./grlimit/grlimit_test.go ===
package grlimit

import (
	"context"
	"errors"
	"testing"
	"time"
)

// Adaptor to build jobs inline in tests.
type JobFunc func(ctx context.Context) error

func (f JobFunc) Run(ctx context.Context) error { return f(ctx) }

func startErrConsumer(g *Gate) (done chan struct{}, got chan error) {
	done = make(chan struct{})
	got = make(chan error, 16)
	go func() {
		defer close(done)
		for err := range g.Errors() {
			got <- err
		}
	}()
	return done, got
}

func TestBlocksAtCapacityAndReleases(t *testing.T) {
	g := NewGate(1)
	errsDone, _ := startErrConsumer(g)

	hold := make(chan struct{})
	first := JobFunc(func(ctx context.Context) error {
		<-hold
		return nil
	})
	if err := g.Submit(context.Background(), first); err != nil {
		t.Fatalf("submit first: %v", err)
	}

	// Second should block; we use a short timeout context to prove it blocks.
	ctx, cancel := context.WithTimeout(context.Background(), 120*time.Millisecond)
	defer cancel()
	second := JobFunc(func(ctx context.Context) error { return nil })

	if err := g.Submit(ctx, second); !errors.Is(err, context.DeadlineExceeded) {
		t.Fatalf("expected deadline exceeded while full, got %v", err)
	}

	// Now free the first; second should get in immediately.
	close(hold)
	if err := g.Submit(context.Background(), second); err != nil {
		t.Fatalf("submit after release: %v", err)
	}

	g.CloseAndWait()
	<-errsDone
}

func TestShutdownPreventsAdmission(t *testing.T) {
	g := NewGate(2)
	errsDone, _ := startErrConsumer(g)

	g.CloseAndWait()

	if err := g.Submit(context.Background(), JobFunc(func(ctx context.Context) error { return nil })); !errors.Is(err, ErrShutdown) {
		t.Fatalf("expected ErrShutdown after CloseAndWait, got %v", err)
	}
	<-errsDone
}

func TestErrorsForwarded(t *testing.T) {
	g := NewGate(1)
	errCh := g.Errors()

	want := errors.New("boom")
	if err := g.Submit(context.Background(), JobFunc(func(ctx context.Context) error { return want })); err != nil {
		t.Fatalf("submit: %v", err)
	}

	g.CloseAndWait()
	select {
	case err := <-errCh:
		if !errors.Is(err, want) {
			t.Fatalf("want %v, got %v", want, err)
		}
	case <-time.After(500 * time.Millisecond):
		t.Fatalf("timed out waiting for error")
	}
}

func TestPanicDoesNotLeakSlot(t *testing.T) {
	g := NewGate(1)
	errsDone, _ := startErrConsumer(g)

	// First job panics; token must still be released by defer.
	_ = g.Submit(context.Background(), JobFunc(func(ctx context.Context) error {
		panic("kaboom")
	}))

	// Second should still be able to enter soon.
	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	defer cancel()
	if err := g.Submit(ctx, JobFunc(func(ctx context.Context) error { return nil })); err != nil {
		t.Fatalf("submit after panic job: %v", err)
	}

	g.CloseAndWait()
	<-errsDone
}

func TestInUseAndAvailable(t *testing.T) {
	g := NewGate(3)
	errsDone, _ := startErrConsumer(g)

	hold := make(chan struct{})
	job := JobFunc(func(ctx context.Context) error { <-hold; return nil })
	if err := g.Submit(context.Background(), job); err != nil {
		t.Fatalf("submit: %v", err)
	}

	if got := g.InUse(); got != 1 {
		t.Fatalf("InUse = %d, want 1", got)
	}
	if got := g.Available(); got != 2 {
		t.Fatalf("Available = %d, want 2", got)
	}

	close(hold)
	g.CloseAndWait()
	<-errsDone
}

func TestSubmitRespectsContextBeforeAdmission(t *testing.T) {
	g := NewGate(1)
	errsDone, _ := startErrConsumer(g)

	hold := make(chan struct{})
	_ = g.Submit(context.Background(), JobFunc(func(ctx context.Context) error {
		<-hold
		return nil
	}))

	// Gate is full; this submit should time out and must not increase InUse.
	ctx, cancel := context.WithTimeout(context.Background(), 120*time.Millisecond)
	defer cancel()
	_ = g.Submit(ctx, JobFunc(func(ctx context.Context) error { return nil })) // expect ctx error

	if got := g.InUse(); got != 1 {
		t.Fatalf("InUse = %d, want 1", got)
	}

	close(hold)
	g.CloseAndWait()
	<-errsDone
}


=== ./grlimit/go.mod ===
module github.com/Andrej220/go-utils/grlimit

go 1.23

=== ./grlimit/grlimit.go ===
package grlimit

import (
	"context"
	"errors"
	"sync/atomic"
)

var (
	ErrShutdown        = errors.New("gate is shutting down")
	ErrNilJobSubmitted = errors.New("nil job submitted")
)

const (
	defaultErrBuffer = 10
)

// Job represents a unit of work. Implementations should respect ctx for cancellation.
type Job interface {
	Run(ctx context.Context) error
}

// Gate limits the number of concurrently running jobs.
// One-shot: after CloseAndWait, Submit will return ErrShutdown and Errors() is closed.
type Gate struct {
	closed atomic.Bool
	sem    chan struct{} // max concurrent jobs
	errs   chan error
}

// NewGate creates a new go routine limiter with the given capacity.
func NewGate(cap int) *Gate {
	if cap <= 0 {
		cap = 1
	}

	return &Gate{
		sem:  make(chan struct{}, cap),
		errs: make(chan error, defaultErrBuffer),
	}
}

// Submit blocks until a slot is available or ctx is canceled.
// Returns ErrShutdown after the gate has been closed.
func (g *Gate) Submit(ctx context.Context, jb Job) error {

	if jb == nil {
		return ErrNilJobSubmitted
	}

	if g.closed.Load() {
		return ErrShutdown
	}

	select {
	case g.sem <- struct{}{}: //take a slot
		// prevent starting after shutdown flipped
		if g.closed.Load() {
			<-g.sem
			return ErrShutdown
		}
		go g.worker(ctx, jb)
		return nil
	case <-ctx.Done():
		return ctx.Err()
	}
}

// CloseAndWait stops admissions and waits for all in-flight jobs to finish.
// Afterwards, Errors() is closed and Submit will return ErrShutdown.
func (g *Gate) CloseAndWait() {
	if g.closed.Swap(true) {
		return // already closed
	}
	// Acquire all capacity tokens, this blocks until no job holds a token
	for i := 0; i < g.Capacity(); i++ {
		g.sem <- struct{}{}
	}
	// draining queue -> idle state, if reuse is implemented
	//for i := 0; i < g.Capacity(); i++ {
	//	<-g.sem
	//}
	close(g.errs)
}

func (g *Gate) InUse() int           { return len(g.sem) }
func (g *Gate) Capacity() int        { return cap(g.sem) }
func (g *Gate) Errors() <-chan error { return g.errs }
func (g *Gate) Available() int       { return g.Capacity() - g.InUse() }

func (g *Gate) worker(ctx context.Context, jb Job) {
	defer func() { <-g.sem }() // Release ticket
	defer func() {
		if r := recover(); r != nil {
			//TODO: log panic
		}
	}()

	select {
	case <-ctx.Done():
		return
	default:
	}
	err := jb.Run(ctx)
	if err != nil {
		select {
		case g.errs <- err:
		default:
			//TODO: chanell appears to be full, log it
		}
	}

}


=== ./httpsrv/httpserver.go ===
package srvx

import (
	"context"
	"encoding/json"
	"errors"
	"io"
	"mime"
	"net"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	lg "github.com/azargarov/go-utils/zlog"
	"go.uber.org/zap/zapcore"
)

// ServerConfig holds configuration of HTTP server.
type ServerConfig struct {
	Port            string
	Addr            string
	ReadTimeout     time.Duration
	WriteTimeout    time.Duration
	IdleTimeout     time.Duration
	ShutdownTimeout time.Duration
	Logger          lg.ZLogger
	EnvPortKey      string
}

const (
	defaultPort              = "8081"
	defaultAddr              = ""
	defaultReadTimeout       = 10 * time.Second
	defaultReadHeaderTimeout = 5 * time.Second
	defaultWriteTimeout      = 10 * time.Second
	defaultIdleTimeout       = 120 * time.Second
	defaultShutdownTimeout   = 30 * time.Second
	defaultMaxBody           = 1 << 20
	defaultEnvPortKey        = "EXECUTORPORT"
)

// Per-type key variant
type reqKey[T any] struct{}

func WithRequest[T any](ctx context.Context, v *T) context.Context {
	return context.WithValue(ctx, reqKey[T]{}, v)
}

func GetRequest[T any](ctx context.Context) (*T, bool) {
	v, ok := ctx.Value(reqKey[T]{}).(*T)
	return v, ok
}

func normalize(c ServerConfig) ServerConfig {
	if c.EnvPortKey == "" {
		c.EnvPortKey = defaultEnvPortKey
	}
	if c.ReadTimeout == 0 {
		c.ReadTimeout = defaultReadTimeout
	}
	if c.WriteTimeout == 0 {
		c.WriteTimeout = defaultWriteTimeout
	}
	if c.IdleTimeout == 0 {
		c.IdleTimeout = defaultIdleTimeout
	}
	if c.ShutdownTimeout == 0 {
		c.ShutdownTimeout = defaultShutdownTimeout
	}
	if c.Port == "" {
		if p := os.Getenv(c.EnvPortKey); p != "" {
			c.Port = p
		} else {
			c.Port = defaultPort
		}
	}
	if c.Addr == "" {
		c.Addr = defaultAddr
	}
	return c
}

func DefaultServerConfig(l lg.ZLogger) ServerConfig {
	return ServerConfig{
		Port:            defaultPort,
		ReadTimeout:     defaultReadTimeout,
		WriteTimeout:    defaultWriteTimeout,
		IdleTimeout:     defaultIdleTimeout,
		ShutdownTimeout: defaultShutdownTimeout,
		Logger:          l,
		EnvPortKey:      defaultEnvPortKey,
	}
}

func RunServer(handler http.Handler, config ServerConfig) error {
	// DONE: pass listening port with environment variable, for different services...

	//if handler is nil, the server uses default one
	if handler == nil {
		handler = http.NewServeMux()
	}

	config = normalize(config)
	var logger lg.ZLogger
	if config.Logger != nil {
		logger = config.Logger
	} else {
		logger = lg.NewDefault("Default")
	}

	srvAddr := net.JoinHostPort(config.Addr, config.Port)
	errorLog := lg.StdLoggerAt(logger, zapcore.ErrorLevel)

	server := &http.Server{
		Addr:              srvAddr,
		Handler:           handler,
		ReadTimeout:       config.ReadTimeout,
		WriteTimeout:      config.WriteTimeout,
		IdleTimeout:       config.IdleTimeout,
		ReadHeaderTimeout: defaultReadHeaderTimeout,
		ErrorLog:          errorLog,
	}
	// Channel to listen interrupt signals
	sigc := make(chan os.Signal, 1)
	signal.Notify(sigc, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)
	defer signal.Stop(sigc)

	serveErr := make(chan error, 1)

	go func() {
		logger.Info("Server starting", lg.String("addr", srvAddr))
		serveErr <- server.ListenAndServe()
	}()

	select {
	case sig := <-sigc:
		logger.Info("shutdown signal", lg.String("signal", sig.String()))
	case err := <-serveErr:
		if err != nil && err != http.ErrServerClosed {
			return err
		}
	}

	ctx, cancel := context.WithTimeout(context.Background(), config.ShutdownTimeout)
	defer cancel()

	// Attempt gracefully shutdown the server
	if err := server.Shutdown(ctx); err != nil {
		logger.Error("Server shutdown failed", lg.Any("error", err))
		return err
	}

	// drain serveErr
	select {
	case err := <-serveErr:
		if err != nil && err != http.ErrServerClosed {
			logger.Error("server listener error", lg.Any("error", err))
			return err
		}
	default:
	}

	logger.Info("Server stopped gracefully")
	return nil
}

type ValidationHandler[T any] struct {
	next      http.Handler
	validator func(*T) error
}

func NewValidationHandler[T any](next http.Handler, validator ...func(*T) error) http.Handler {
	// DONE: implement a default validator
	var validateFunc func(*T) error
	if len(validator) > 0 {
		validateFunc = validator[0]
	} else {
		validateFunc = defaultValidator[T]
	}

	return &ValidationHandler[T]{
		next:      next,
		validator: validateFunc,
	}
}

func (h *ValidationHandler[T]) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	var request T

	if ct := r.Header.Get("Content-Type"); ct != "" {
		mt, _, _ := mime.ParseMediaType(ct)
		if mt != "application/json" {
			WriteJSONError(rw, APIError{Code: ErrCodeUnsupportedMediaType, Message: "unsupported_media_type", Status: http.StatusUnsupportedMediaType})
			return
		}
	}
	if r.Body == nil {
		WriteJSONError(rw, APIError{Code: ErrCodeEmptyBody, Message: "Request body is required", Status: http.StatusBadRequest})

		return
	}
	defer r.Body.Close()

	r.Body = http.MaxBytesReader(rw, r.Body, defaultMaxBody)
	decoder := json.NewDecoder(r.Body)
	decoder.DisallowUnknownFields()

	err := decoder.Decode(&request)
	if err != nil {
		if errors.Is(err, io.EOF) {
			WriteJSONError(rw, APIError{Code: ErrCodeEmptyBody, Message: "Request body is required", Status: http.StatusBadRequest})
			return
		}
		WriteJSONError(rw, APIError{Code: ErrCodeInvalidJSON, Message: "invalid_json", Status: http.StatusBadRequest})
		return
	}

	if err := h.validator(&request); err != nil {
		WriteJSONError(rw, APIError{Code: ErrValidationFailed, Message: "validation_failed", Status: http.StatusBadRequest})
		return
	}
	// Pass the decoded request to the next handler via context
	ctx := WithRequest(r.Context(), &request)
	h.next.ServeHTTP(rw, r.WithContext(ctx))
}

func defaultValidator[T any](req *T) error {
	return nil
}


=== ./httpsrv/README.md ===
# srvx — tiny HTTP server kit (Go)

A small, focused helper for building HTTP services with:
- sane server defaults,
- graceful shutdown on SIGINT/SIGTERM,
- pluggable logging (integrates with your `zlog`),
- a generic JSON validation middleware,
- safe request-context helpers.

> Package name: **`srvx`**. 

```go
import srvx "github.com/Andrej220/go-utils/httpsrv" 
```

---

## Install

```bash
go get github.com/Andrej220/go-utils/httpsrv@latest
```

---

## Quick start

```go
package main

import (
	"net/http"

	srvx "github.com/Andrej220/go-utils/httpsrv"
	lg   "github.com/Andrej220/go-utils/zlog"
)

func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("/healthz", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusNoContent)
	})

	cfg := srvx.DefaultServerConfig(lg.NewDefault("example-service"))
	// cfg.Addr = ""   // bind all interfaces (default)
	// cfg.Port = "8081" // or from env (see EnvPortKey)
	
	if err := srvx.RunServer(mux, cfg); err != nil {
		panic(err)
	}
}
```

- If you pass `handler == nil`, `srvx` uses a **new, empty mux** (`http.NewServeMux()`).
- Server stops **gracefully** on `SIGINT`/`SIGTERM` (waits up to `ShutdownTimeout`).

---

## Configuration

```go
type ServerConfig struct {
	Port            string
	Addr            string
	ReadTimeout     time.Duration
	WriteTimeout    time.Duration
	IdleTimeout     time.Duration
	ShutdownTimeout time.Duration
	Logger          zlog.ZLogger
	EnvPortKey      string
}
```

**Defaults** (applied via `normalize` when zero values are provided):

| Field                | Default                | Notes |
|----------------------|------------------------|------|
| `Addr`               | `""`                   | Bind all interfaces (use e.g. `127.0.0.1` for localhost only). |
| `Port`               | `"8081"` or from env   | Uses `os.Getenv(EnvPortKey)` first if set. |
| `EnvPortKey`         | `"EXECUTORPORT"`       | Override if you prefer a different env var. |
| `ReadTimeout`        | `10s`                  | |
| `ReadHeaderTimeout`  | `5s`                   | Slowloris hardening (internal default in server construction). |
| `WriteTimeout`       | `10s`                  | |
| `IdleTimeout`        | `120s`                 | |
| `ShutdownTimeout`    | `30s`                  | |

---

## Logging

`srvx` expects your `zlog.ZLogger`. If `nil`, it falls back to `zlog.NewDefault("Default")`.

Internal `net/http` errors are routed into your logger by mapping `http.Server.ErrorLog` to a stdlib logger built from your `zlog`:

```go
errorLog := zlog.StdLoggerAt(logger, zapcore.ErrorLevel)
server := &http.Server{ ErrorLog: errorLog, /* ... */ }
```

> Works with both zap-backed and fallback `defaultLogger` backends.

---

## JSON validation middleware

Bind + validate request JSON and pass the parsed value down the chain via context.

```go
type CreateUser struct {
    Name string `json:"name"`
}

validate := func(c *CreateUser) error {
    if c.Name == "" { return errors.New("name required") }
    return nil
}

mux.Handle("/users",
    srvx.NewValidationHandler[CreateUser](
        http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            body, _ := srvx.GetRequest[CreateUser](r.Context())
            // use body.Name ...
            w.WriteHeader(http.StatusCreated)
        }),
        validate,
    ),
)
```

Features:
- Enforces `Content-Type: application/json` (if present).
- Limits body size (`defaultMaxBody` = 1 MiB).
- `DisallowUnknownFields()` enabled → unknown JSON keys return an error.
- Stores `*T` in context (`WithRequest` / `GetRequest[T]`) using **per-type** keys.

---

## Error model

The middleware returns JSON errors via an `APIError` shape and **stable codes** (you define these in your package). Example suggestion:

```go
const (
    ErrCodeEmptyBody            = "empty_body"
    ErrCodeInvalidJSON          = "invalid_json"
    ErrCodeUnsupportedMediaType = "unsupported_media_type"
    ErrValidationFailed         = "validation_failed"
)

type APIError struct {
    Code    string      `json:"error"`
    Message string      `json:"message"`
    Status  int         `json:"-"`
    Details interface{} `json:"details,omitempty"`
}

func WriteJSONError(w http.ResponseWriter, e APIError) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(e.Status)
    _ = json.NewEncoder(w).Encode(e)
}
```

Usage inside middleware (already wired in your code):

```go
WriteJSONError(w, APIError{Code: ErrCodeEmptyBody, Message: "Request body is required", Status: http.StatusBadRequest})
```

---

## Context helpers

Per-type keys avoid collisions and let you retrieve the exact DTO type:

```go
ctx := srvx.WithRequest(r.Context(), &dto)      // store
dtoPtr, ok := srvx.GetRequest[MyDTO](r.Context()) // load
```

Because the key is `reqKey[T]`, different `T` types won’t overwrite each other.

---

## Testing

Recommended flags:

```bash
go test ./... -v -race -cover
```

Typical unit tests (examples are included in discussion):
- **Graceful shutdown on SIGINT** (server exits cleanly).
- **Port already in use** (returns an error from `ListenAndServe` path).
- **Validation**: unsupported content-type, empty body, unknown fields, success + context retrieval.

---


=== ./httpsrv/httpserver_test.go ===
package srvx

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"net"
	"net/http"
	"net/http/httptest"
	"os"
	"strconv"
	"syscall"
	"testing"
	"time"

	lg "github.com/azargarov/go-utils/zlog"
)

type dto struct{ Name string }

func mustJSON(t testing.TB, v any) io.Reader {
	t.Helper()
	b, err := json.Marshal(v)
	if err != nil {
		t.Fatalf("marshal JSON: %v", err)
	}
	return bytes.NewReader(b)
}

func shortCfg() ServerConfig {
	return ServerConfig{
		Addr:            "127.0.0.1",
		Port:            "0",
		ShutdownTimeout: 200 * time.Millisecond,
		Logger:          lg.Discard, // keep tests quiet
	}

}
func strconvI(p int) string { return strconv.Itoa(p) }

func TestRunServer_GracefulShutdownOnSignal(t *testing.T) {
	mux := http.NewServeMux()
	mux.HandleFunc("/ok", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusNoContent)
	})

	done := make(chan error, 1)
	go func() { done <- RunServer(mux, shortCfg()) }()

	// Give the server a moment to start
	time.Sleep(100 * time.Millisecond)

	// Send SIGINT to this process; RunServer should catch it and exit cleanly
	_ = syscall.Kill(os.Getpid(), syscall.SIGINT)

	select {
	case err := <-done:
		if err != nil {
			t.Fatalf("RunServer returned error on graceful shutdown: %v", err)
		}
	case <-time.After(3 * time.Second):
		t.Fatal("RunServer did not exit after SIGINT")
	}
}

func TestRunServer_PortInUseReturnsError(t *testing.T) {
	ln, err := net.Listen("tcp", "127.0.0.1:0")
	if err != nil {
		t.Fatalf("listen: %v", err)
	}
	defer ln.Close()
	port := ln.Addr().(*net.TCPAddr).Port

	// Using same port should cause immediate ListenAndServe error (serveErr path)
	cfg := ServerConfig{
		Addr:            "127.0.0.1",
		Port:            func() string { return strconvI(port) }(),
		ShutdownTimeout: 200 * time.Millisecond,
		Logger:          lg.Discard,
	}
	err = RunServer(http.NewServeMux(), cfg)
	if err == nil {
		t.Fatal("expected error due to address already in use, got nil")
	}
}

func TestValidationHandler_UnsupportedContentType(t *testing.T) {
	next := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { t.Fatal("next should not be called") })
	h := NewValidationHandler[dto](next)

	req := httptest.NewRequest(http.MethodPost, "/", bytes.NewBufferString(`{}`))
	req.Header.Set("Content-Type", "text/plain")
	rr := httptest.NewRecorder()

	h.ServeHTTP(rr, req)

	if rr.Code != http.StatusUnsupportedMediaType {
		t.Fatalf("want %d got %d", http.StatusUnsupportedMediaType, rr.Code)
	}
	if !bytes.Contains(rr.Body.Bytes(), []byte(`"unsupported_media_type"`)) {
		t.Fatalf("want JSON error with unsupported_media_type, got: %s", rr.Body.String())
	}
}

func TestValidationHandler_EmptyBody(t *testing.T) {
	next := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { t.Fatal("next should not be called") })
	h := NewValidationHandler[dto](next)

	req := httptest.NewRequest(http.MethodPost, "/", nil) // Body == nil
	rr := httptest.NewRecorder()

	h.ServeHTTP(rr, req)

	if rr.Code != http.StatusBadRequest {
		t.Fatalf("want 400 got %d", rr.Code)
	}

	resp := APIError{}

	_ = json.Unmarshal(rr.Body.Bytes(), &resp)
	if resp.Code != ErrCodeEmptyBody || rr.Code != http.StatusBadRequest {
		t.Fatalf("want error=%s got %v", ErrCodeEmptyBody, resp.Code)
	}
}

func TestValidationHandler_UnknownFields(t *testing.T) {
	next := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { t.Fatal("next should not be called") })
	h := NewValidationHandler[dto](next)

	req := httptest.NewRequest(http.MethodPost, "/", bytes.NewBufferString(`{"Name":"a","extra":1}`))
	req.Header.Set("Content-Type", "application/json")
	rr := httptest.NewRecorder()

	h.ServeHTTP(rr, req)

	if rr.Code != http.StatusBadRequest {
		t.Fatalf("want 400 got %d", rr.Code)
	}
	if !bytes.Contains(rr.Body.Bytes(), []byte(`"invalid_json"`)) {
		t.Fatalf("unexpected body: %s", rr.Body.String())
	}
}

func TestValidationHandler_SuccessAndContext(t *testing.T) {
	nextCalled := false
	next := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		nextCalled = true
		got, ok := GetRequest[dto](r.Context())
		if !ok || got == nil || got.Name != "alice" {
			t.Fatalf("GetRequest failed: ok=%v got=%v", ok, got)
		}
		w.WriteHeader(http.StatusNoContent)
	})
	h := NewValidationHandler[dto](next)

	req := httptest.NewRequest(http.MethodPost, "/", mustJSON(t, dto{Name: "alice"}))
	req.Header.Set("Content-Type", "application/json")
	rr := httptest.NewRecorder()

	h.ServeHTTP(rr, req)

	if rr.Code != http.StatusNoContent {
		t.Fatalf("want 204 got %d", rr.Code)
	}
	if !nextCalled {
		t.Fatal("next handler not called")
	}
}

func TestWithRequest_PerTypeKeyIsolation(t *testing.T) {
	type A struct{ X int }
	type B struct{ Y int }

	ctx := context.Background()
	ctx = WithRequest(ctx, &A{X: 1})
	ctx = WithRequest(ctx, &B{Y: 2})

	if a, ok := GetRequest[A](ctx); !ok || a == nil || a.X != 1 {
		t.Fatalf("GetRequest[A] failed: %v %v", ok, a)
	}
	if b, ok := GetRequest[B](ctx); !ok || b == nil || b.Y != 2 {
		t.Fatalf("GetRequest[B] failed: %v %v", ok, b)
	}
}

func TestNormalize_UsesEnvPort(t *testing.T) {
	const key = "SRVX_TEST_PORT"
	t.Setenv(key, "9099")
	got := normalize(ServerConfig{EnvPortKey: key})
	if got.Port != "9099" {
		t.Fatalf("env port not applied, got %q", got.Port)
	}
}

// nil handler should not crash
func TestRunServer_DefaultHandlerWhenNil(t *testing.T) {
	done := make(chan error, 1)
	go func() { done <- RunServer(nil, shortCfg()) }()

	time.Sleep(100 * time.Millisecond)
	_ = syscall.Kill(os.Getpid(), syscall.SIGINT)

	select {
	case err := <-done:
		if err != nil {
			t.Fatalf("RunServer returned error: %v", err)
		}
	case <-time.After(3 * time.Second):
		t.Fatal("timeout waiting for RunServer to exit")
	}
}


=== ./httpsrv/go.mod ===
module github.com/azargarov/go-utils/httpsrv

go 1.23

require (
	github.com/azargarov/go-utils/zlog v0.1.1
	go.uber.org/zap v1.27.0
)

require go.uber.org/multierr v1.10.0 // indirect


=== ./httpsrv/errors.go ===
package srvx

import (
	"encoding/json"
	"net/http"
)

const (
	ErrCodeEmptyBody            = "empty_body"
	ErrCodeInvalidJSON          = "invalid_json"
	ErrCodeUnsupportedMediaType = "unsupported_media_type"
	ErrValidationFailed         = "validation_failed"
)

type APIError struct {
	Code    string      `json:"error"`
	Message string      `json:"message"`
	Status  int         `json:"-"`
	Details interface{} `json:"details,omitempty"`
}

func WriteJSONError(w http.ResponseWriter, e APIError) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(e.Status)
	_ = json.NewEncoder(w).Encode(e)
}

//func writeJSONError(w http.ResponseWriter, code int, err, msg string) {
//    w.Header().Set("Content-Type", "application/json")
//    w.WriteHeader(code)
//    _ = json.NewEncoder(w).Encode(map[string]any{"error": err, "message": msg})
//}


=== ./go.work ===
go 1.23.6

use (
	./autostr
	./backoff
	./grlimit
	./httpsrv
	./wpool
	./zlog
)


=== ./wpool/go.sum ===
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/stretchr/testify v1.8.1 h1:w7B6lhMri9wdJUVmEZPGGhZzrYTPvgJArz7wNPgYKsk=
github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
go.uber.org/goleak v1.3.0 h1:2K3zAYmnTNqV73imy9J1T3WC+gmCePx2hEGkimedGto=
go.uber.org/goleak v1.3.0/go.mod h1:CoHD4mav9JJNrW/WLlf7HGZPjdw8EucARQHekz1X6bE=
go.uber.org/multierr v1.10.0 h1:S0h4aNzvfcFsC3dRF1jLoaov7oRaKqRGC/pUEJ2yvPQ=
go.uber.org/multierr v1.10.0/go.mod h1:20+QtiLqy0Nd6FdQB9TLXag12DsQkrbs3htMFfDN80Y=
go.uber.org/zap v1.27.0 h1:aJMhYGrd5QSmlpLMr2MftRKl7t8J8PTZPA732ud/XR8=
go.uber.org/zap v1.27.0/go.mod h1:GB2qFLM7cTU87MWRP2mPIjqfIDnGu+VIO4V/SdhGo2E=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=


=== ./wpool/wpool_test.go ===
package workerpool

import (
	"context"
	"errors"
	"sync"
	"sync/atomic"
	"testing"
	"time"
)

var fastRetry = RetryPolicy{Attempts: 3, Initial: 5 * time.Millisecond, Max: 10 * time.Millisecond}

func TestDefultRetryPolicy(t *testing.T) {
	rp := GetDefaultRP()
	if rp == nil {
		t.Fatalf("Default Retry Polic is nil")
	}

	if rp.Attempts != defaultAttempts || rp.Initial != defaultInitialRetry || rp.Max != defauiltMaxRetry {
		t.Fatal("Defauilt retry policy is not default")
	}
}

func TestJobSuccess(t *testing.T) {
	p := NewPool[int](2, fastRetry)
	defer p.Stop()

	done := make(chan struct{})
	jobCtx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
	defer cancel()

	err := p.Submit(Job[int]{
		Payload: 1,
		Ctx:     jobCtx,
		Fn: func(n int) error {
			close(done)
			return nil
		},
	})
	if err != nil {
		t.Fatalf("submit: %v", err)
	}

	select {
	case <-done:
	case <-time.After(500 * time.Millisecond):
		t.Fatal("job did not complete")
	}
	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	defer cancel()
	_ = p.Shutdown(ctx)
	if got := p.ActiveWorkers(); got != 0 {
		t.Fatalf("active workers = %d; want 0", got)
	}
}

func TestRetryThenSuccess(t *testing.T) {
	p := NewPool[int](1, fastRetry)
	defer p.Stop()

	var attempts int32
	done := make(chan struct{})

	jobCtx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
	defer cancel()

	err := p.Submit(Job[int]{
		Payload: 42,
		Ctx:     jobCtx,
		Retry:   &RetryPolicy{Attempts: 3, Initial: 2 * time.Millisecond, Max: 5 * time.Millisecond},
		Fn: func(_ int) error {
			if atomic.AddInt32(&attempts, 1) < 3 {
				return errors.New("fail")
			}
			close(done)
			return nil
		},
	})
	if err != nil {
		t.Fatalf("submit: %v", err)
	}

	select {
	case <-done:
	case <-time.After(1 * time.Second):
		t.Fatal("job did not succeed after retries")
	}

	if got := atomic.LoadInt32(&attempts); got != 3 {
		t.Fatalf("attempts = %d; want 3", got)
	}
}

func TestCancelDuringBackoff(t *testing.T) {
	p := NewPool[int](1, fastRetry)
	defer p.Stop()

	var attempts int32
	step := make(chan struct{})
	jobCtx, cancel := context.WithCancel(context.Background())

	err := p.Submit(Job[int]{
		Payload: 7,
		Ctx:     jobCtx,
		Retry:   &RetryPolicy{Attempts: 5, Initial: 100 * time.Millisecond, Max: 100 * time.Millisecond},
		Fn: func(_ int) error {
			atomic.AddInt32(&attempts, 1)
			close(step)
			return errors.New("boom")
		},
	})
	if err != nil {
		t.Fatalf("submit: %v", err)
	}

	// wait until first attempt happened, then cancel during backoff
	select {
	case <-step:
	case <-time.After(200 * time.Millisecond):
		t.Fatal("first attempt did not happen in time")
	}
	cancel()

	time.Sleep(50 * time.Millisecond) // allow worker to observe cancel
	if got := atomic.LoadInt32(&attempts); got != 1 {
		t.Fatalf("attempts after cancel = %d; want 1", got)
	}
}

func TestShutdownTimeout(t *testing.T) {
	p := NewPool[int](1, fastRetry)

	started := make(chan struct{})
	done := make(chan struct{})

	_ = p.Submit(Job[int]{
		Payload: 1,
		Ctx:     context.Background(),
		Fn: func(int) error {
			close(started)
			time.Sleep(300 * time.Millisecond)
			close(done)
			return nil
		},
	})

	<-started

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Millisecond)
	defer cancel()
	err := p.Shutdown(ctx)
	if !errors.Is(err, context.DeadlineExceeded) {
		t.Fatalf("Shutdown err = %v; want deadline exceeded", err)
	}

	<-done
	if err := p.Shutdown(context.Background()); err != nil {
		t.Fatalf("second Shutdown err = %v; want nil", err)
	}
}

func TestSubmitAfterShutdown(t *testing.T) {
	p := NewPool[int](1, fastRetry)
	_ = p.Shutdown(context.Background())

	if ok := p.TrySubmit(Job[int]{Payload: 1, Ctx: context.Background(), Fn: func(int) error { return nil }}); ok {
		t.Fatal("TrySubmit succeeded on closed pool; want false")
	}
	if err := p.Submit(Job[int]{Payload: 1, Ctx: context.Background(), Fn: func(int) error { return nil }}); err == nil {
		t.Fatal("Submit succeeded on closed pool; want error")
	}
}

func TestPanicRecoveryAndCleanup(t *testing.T) {
	p := NewPool[int](1, fastRetry)
	defer p.Stop()

	var mu sync.Mutex
	cleaned := 0
	secondDone := make(chan struct{})

	// first job panics
	_ = p.Submit(Job[int]{
		Payload: 1,
		Ctx:     context.Background(),
		Fn: func(int) error {
			panic("boom")
		},
		CleanupFunc: func() {
			mu.Lock()
			cleaned++
			mu.Unlock()
		},
	})

	// second job should still run
	_ = p.Submit(Job[int]{
		Payload: 2,
		Ctx:     context.Background(),
		Fn: func(int) error {
			close(secondDone)
			return nil
		},
		CleanupFunc: func() {
			mu.Lock()
			cleaned++
			mu.Unlock()
		},
	})

	select {
	case <-secondDone:
	case <-time.After(500 * time.Millisecond):
		t.Fatal("second job did not complete after first panicked")
	}

	// allow cleanup defers to run
	time.Sleep(10 * time.Millisecond)

	mu.Lock()
	defer mu.Unlock()
	if cleaned != 2 {
		t.Fatalf("cleanup called %d times; want 2", cleaned)
	}
}


=== ./wpool/README.md ===
# workerpool

A tiny, **bounded-concurrency** worker pool for Go with **per‑job retries**, **context‑aware cancelation**, **panic recovery**, and **graceful shutdown with timeout**.

- Generic over payload type `T`.
- Per‑pool defaults + per‑job `RetryPolicy` overrides.
- Context-aware backoff (stops sleeping when the job is canceled).
- `Submit` (blocking) and `TrySubmit` (non‑blocking).
- `Shutdown(ctx)` to close the pool and wait up to a deadline.
- Safe cleanup callbacks and panic isolation (a panicking job won’t kill the worker).

---

## Install

```bash
go get github.com/Andrej220/go-utils/workerpool
```

---

## Quick start

```go
package main

import (
	"context"
	"fmt"
	"time"

	wp "github.com/Andrej220/go-utils/workerpool"
)

func main() {
	// Create a pool with 4 workers and sane default retry policy.
	pool := wp.NewPool[int](4, wp.RetryPolicy{
		Attempts: 3,
		Initial:  200 * time.Millisecond,
		Max:      5 * time.Second,
	})
	defer pool.Stop() // blocks until all jobs complete

	// Submit a job with a 3s timeout.
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()

	_ = pool.Submit(wp.Job[int]{
		Payload: 42,
		Ctx:     ctx,
		Fn: func(n int) error {
			fmt.Println("processing", n)
			return nil
		},
	})
}
```

---

## Per‑job retry override

Override the pool defaults for a specific job:

```go
_ = pool.Submit(wp.Job[int]{
	Payload: 1,
	Ctx:     context.Background(),
	Retry:   &wp.RetryPolicy{Attempts: 5, Initial: 50 * time.Millisecond, Max: 500 * time.Millisecond},
	Fn: func(n int) error {
		// do work; return error to trigger retry/backoff
		return fmt.Errorf("transient failure")
	},
})
```

---

## Cancel during backoff (context‑aware)

Backoff sleep stops early if the job’s context is canceled:

```go
ctx, cancel := context.WithTimeout(context.Background(), 300*time.Millisecond)
defer cancel()

_ = pool.Submit(wp.Job[int]{
	Payload: 7,
	Ctx:     ctx,
	Fn: func(int) error {
		// return an error so the pool enters backoff; the timeout cancels it
		return fmt.Errorf("boom")
	},
})
```

---

## Graceful shutdown with deadline

`Shutdown(ctx)` stops submissions, closes the jobs channel, and waits for workers up to `ctx`’s deadline:

```go
// Ask workers to finish within 5s.
shCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

if err := pool.Shutdown(shCtx); err != nil {
	// context.DeadlineExceeded if not all jobs finished in time
}
```

`Stop()` is equivalent to `Shutdown(context.Background())` (waits indefinitely).

---

## API

### Types

```go
type RetryPolicy struct {
	Attempts int           // number of tries; >=1
	Initial  time.Duration // first backoff
	Max      time.Duration // cap for backoff
}

type JobFunc[T any] func(T) error

type Job[T any] struct {
	Payload     T
	Fn          JobFunc[T]
	Ctx         context.Context      // nil -> context.Background()
	CleanupFunc func()               // optional; always called
	Retry       *RetryPolicy         // nil -> pool default
}

type Pool[T any] struct { /* ... */ }
```

### Constructors & methods

```go
func NewPool[T any](maxWorkers int, defaultRetry RetryPolicy) *Pool[T]

// Queue a job (blocks if the channel buffer is full). Returns error if pool is closed.
func (p *Pool[T]) Submit(job Job[T]) error

// Try to queue a job without blocking. Returns false if buffer full or pool is closed.
func (p *Pool[T]) TrySubmit(job Job[T]) bool

// Close the pool and wait for workers up to ctx deadline (drains queued jobs).
func (p *Pool[T]) Shutdown(ctx context.Context) error

// Wait forever (no deadline). Legacy convenience.
func (p *Pool[T]) Stop()

func (p *Pool[T]) ActiveWorkers() int32
func (p *Pool[T]) QueueLength() int
```

---

## Design notes

- **Bounded concurrency:** fixed worker count reads from a buffered `jobs` channel (size `2 * maxWorkers` by default).
- **Draining on shutdown:** `Shutdown` closes `jobs`; workers exit after the buffer is drained and in‑flight jobs finish (or their contexts cancel).
- **Backoff:** uses your `github.com/Andrej220/go-utils/backoff` generator.
- **Panic safety:** worker wraps each job in `recover()` so a crashing job doesn’t kill the worker.
- **Context everywhere:** jobs can time out or be canceled; backoff sleeps are interruptible via `ctx.Done()`.
- **Logging:** if you inject a logger into `context` (e.g., your `zlog` helper), the pool will use it; otherwise it’s a no‑op.

---

## Testing

This package is designed for unit tests:
- Tiny retry/backoff values speed up tests.
- See sample tests for: success, retry, cancel‑during‑backoff, shutdown deadline, panic recovery, cleanup callbacks.

Run:
```bash
go test ./...
```



=== ./wpool/go.mod ===
module github.com/azargarov/go-utils/wpool

go 1.23.6

require (
	github.com/azargarov/go-utils/backoff v0.1.0
	github.com/azargarov/go-utils/zlog v0.1.0
)

require (
	go.uber.org/multierr v1.10.0 // indirect
	go.uber.org/zap v1.27.0 // indirect
)


=== ./wpool/wpool.go ===
package workerpool

import (
	"context"
	"fmt"
	boff "github.com/azargarov/go-utils/backoff"
	lg "github.com/azargarov/go-utils/zlog"
	"sync"
	"sync/atomic"
	"time"
)

const (
	DefaultMaxWorkers   = 10
	defaultAttempts     = 3
	defaultInitialRetry = 200 * time.Millisecond
	defauiltMaxRetry    = 5 * time.Second
)

type RetryPolicy struct {
	Attempts int
	Initial  time.Duration
	Max      time.Duration
}

type JobFunc[T any] func(T) error

type Job[T any] struct {
	Payload     T
	Fn          JobFunc[T]
	Ctx         context.Context
	CleanupFunc func()
	Retry       *RetryPolicy
}

type Pool[T any] struct {
	jobs           chan Job[T]
	wg             sync.WaitGroup
	maxWorkers     int
	activeWorkers  atomic.Int32
	stopOnce       sync.Once
	closed         chan struct{} // signals no more submissions
	defaultRetry   RetryPolicy
	submitBufRatio int
}

func GetDefaultRP() *RetryPolicy {
	rp := RetryPolicy{
		Attempts: defaultAttempts,
		Initial:  defaultInitialRetry,
		Max:      defauiltMaxRetry,
	}
	return &rp
}

func NewPool[T any](maxWorkers int, defaultRetry RetryPolicy) *Pool[T] {
	if maxWorkers <= 0 {
		maxWorkers = DefaultMaxWorkers
	}
	if defaultRetry.Attempts <= 0 {
		defaultRetry.Attempts = defaultAttempts
	}
	if defaultRetry.Initial <= 0 {
		defaultRetry.Initial = defaultInitialRetry
	}
	if defaultRetry.Max <= 0 {
		defaultRetry.Max = defauiltMaxRetry
	}

	p := &Pool[T]{
		jobs:           make(chan Job[T], maxWorkers*2),
		maxWorkers:     maxWorkers,
		closed:         make(chan struct{}),
		defaultRetry:   defaultRetry,
		submitBufRatio: 2,
	}
	for i := 0; i < p.maxWorkers; i++ {
		p.wg.Add(1)
		go p.worker()
	}
	return p
}

// None-blocking pull stop
func (p *Pool[T]) Shutdown(ctx context.Context) error {
	var already bool
	p.stopOnce.Do(func() {
		close(p.closed) // reject new jobs
		close(p.jobs)   // drain
	})
	// detect if we already closed before
	select {
	case <-p.closed:
		already = true
	default:
	}
	if !already {
		close(p.closed)
	}
	done := make(chan struct{})
	go func() {
		defer close(done)
		p.wg.Wait()
	}()
	select {
	case <-done:
		return nil
	case <-ctx.Done():
		return ctx.Err()
	}
}

// blocking stop
func (p *Pool[T]) Stop() { _ = p.Shutdown(context.Background()) }

func (p *Pool[T]) Submit(job Job[T]) error {
	if job.Ctx == nil {
		job.Ctx = context.Background()
	}
	select {
	case <-p.closed:
		return fmt.Errorf("workerpool: pool closed")
	default:
	}
	select {
	case p.jobs <- job:
		lg.FromContext(job.Ctx).Info("Job submitted", lg.Any("job", job.Payload))
		return nil
	case <-p.closed:
		return fmt.Errorf("workerpool: pool closed")
	}
}

// Non-blocking submit.
func (p *Pool[T]) TrySubmit(job Job[T]) bool {
	if job.Ctx == nil {
		job.Ctx = context.Background()
	}
	select {
	case <-p.closed:
		return false
	default:
	}
	select {
	case p.jobs <- job:
		return true
	default:
		return false
	}
}

func (p *Pool[T]) worker() {
	defer p.wg.Done()
	for job := range p.jobs {
		p.activeWorkers.Add(1)
		func() {
			defer p.activeWorkers.Add(-1)
			defer func() {
				if r := recover(); r != nil {
					lg.FromContext(job.Ctx).Error("job panicked", lg.Any("panic", r))
				}
				if job.CleanupFunc != nil {
					job.CleanupFunc()
				}
			}()
			p.processJob(job)
		}()
	}
}

func (p *Pool[T]) processJob(job Job[T]) {
	logger := lg.FromContext(job.Ctx).With(lg.Any("job", job.Payload))
	logger.Info("Worker processing job", lg.Int32("active_workers", p.activeWorkers.Load()))

	pol := p.defaultRetry
	if job.Retry != nil {
		// override non-zero per-job values
		if job.Retry.Attempts > 0 {
			pol.Attempts = job.Retry.Attempts
		}
		if job.Retry.Initial > 0 {
			pol.Initial = job.Retry.Initial
		}
		if job.Retry.Max > 0 {
			pol.Max = job.Retry.Max
		}
	}

	bo := boff.New(pol.Initial, pol.Max, time.Now().UnixNano())

	for attempt := 1; attempt <= pol.Attempts; attempt++ {
		if err := job.Fn(job.Payload); err == nil {
			logger.Info("Worker finished", lg.Int32("active_workers", p.activeWorkers.Load()))
			return
		} else if attempt == pol.Attempts {
			logger.Error("Worker error", lg.Int("attempt", attempt), lg.Any("error", err))
			return
		} else {
			delay := bo.Next()
			logger.Warn("job attempt failed; backing off",
				lg.Int("attempt", attempt),
				lg.String("sleep", delay.String()),
				lg.Any("error", err),
			)
			timer := time.NewTimer(delay)
			select {
			case <-timer.C:
			case <-job.Ctx.Done():
				if !timer.Stop() {
					<-timer.C // drain if timer is fired
				}
				logger.Info("Job canceled", lg.Any("reason", job.Ctx.Err()))
				return
			}
		}
	}
}

func (p *Pool[T]) ActiveWorkers() int32 { return p.activeWorkers.Load() }
func (p *Pool[T]) QueueLength() int     { return len(p.jobs) }


